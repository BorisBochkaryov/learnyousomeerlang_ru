\documentclass[a4paper,12pt]{report}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{wrapfig}


\lstset{literate=%
    {é}{{\'e}}1
    {Ô}{{\^O}}1
}
\newcommand\mytilde{\char`\~}
\lstset{extendedchars=\true}
\lstset{inputencoding=ansinew}

\setlength{\parindent}{1cm}

\definecolor{gray}{rgb}{0.8, 0.8, 0.8}
\definecolor{lgreen}{HTML}{EEFFCC}
\definecolor{lorange}{HTML}{FBF4E9}
\definecolor{lgray}{HTML}{EFF3F8}

\lstset{frame=single, language=Erlang, backgroundcolor=\color{gray}, basicstyle=\footnotesize\ttfamily, commentstyle=\color{green}}
\lstdefinestyle{repl}{
    frame=single, 
    language=erlang, 
    backgroundcolor=\color{lgray}, 
    basicstyle=\ttfamily, 
    columns=fixed, 
    commentstyle=\color{green}, 
    breaklines=true
}
\lstdefinestyle{erlang}{frame=single, language=Erlang, backgroundcolor=\color{lgray}, basicstyle=\footnotesize\ttfamily, commentstyle=\color{green}, breaklines=true, breakautoindent=true}

\graphicspath { {images/} }
\newcommand{\ops}{\colorbox{lgreen}}


\begin{document}

\begin{titlepage}
    \begin{center}
        \includegraphics[width=1\textwidth]{title.png}
        \\[5cm]
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft}
                \emph{Автор:}\large\\
                 Frederic Trottier-Hebert
            \end{flushleft}
        \end{minipage}
        \begin{minipage}{0.4\textwidth}
            \begin{flushright}
                \emph{Перевод:}\\
                Maksym Pyrozhok
            \end{flushright}
        \end{minipage}
        \vfill
    \end{center}
\end{titlepage}

\chapter{Введение}

\section{О книге}

Начни изучать Эрланг во имя добра! Чтение этого руководства, скорее всего, будет одним из твоих первых шагов в изучении Erlang, поэтому скажу о нём пару слов.

\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{erlang.png}
\end{wrapfigure}

Во\--первых, идея написать это обучающее руководство появилась у меня после того, как я прочитал \href{http://learnyouahaskell.com}{Изучай Haskell во имя добра!} Miran Lipova\v{c}a. Мне показалось, что ему удалось представить язык в привлекательном свете, и сделать процесс обучения приятным. Я уже был знаком с Мираном, поэтому поинтересовался, как он относится к тому, что я напишу версию его книги, посвящённую Erlang. Идея пришлась ему по душе, так как он и сам интересовался Erlang.

Всё это привело к тому, что я теперь печатаю эти слова. Конечно, были и другие источники мотивации: я считаю что <<порог вхождения>> в язык довольно высок (в web маловато документации и, скорее всего, придётся покупать книги). Поэтому я подумал, что сообществу пригодится руководство похожее на LYAH. Ещё я заметил, что люди приписывали Erlang слишком много или слишком мало достоинств, основываясь при этом на поверхностных суждениях. Есть люди, которые абсолютно уверены, что Erlang это просто разрекламированная пустышка. Даже если бы я хотел их убедить в обратном, знаю, что они вряд ли прочитают эти строки.

Эта книга даёт возможность изучить Erlang тем, кто имеет базовые знания о программировании на императивных языках (таких как C/C++, Java, Python, Ruby и т.д.) и имеет или не имеет представление о функциональном программировании (Haskell, Scala, Erlang, Clojure, OCaml\ldots) Также я хочу, чтобы эта книга честно рассказывала об Erlang, правдиво освещая слабые и сильные стороны языка.

\section{Так что же такое Erlang?}
Во\--первых, Erlang это функциональный язык программирования. Если вам приходилось когда\--либо работать с императивными языками, то вы нормально относитесь к выражениям вроде \ops{i++;} в функциональном программировании такие выражения не разрешаются. Более того, изменять значение любой переменной строго запрещено! Сначала это может прозвучать странно, но если вы припомните уроки математики, то на них всё так и объясняли:\\ 
y = 2\\ 
x = y + 3\\ 
x = 2 + 3\\ 
x = 5\\ 
Если бы я добавил:\\ 
x = 5 + 1\\ 
x = x\\ 
$\therefore 5 = 6$\\ 

То привёл бы вас в замешательство. В функциональном программировании принято так: если я говорю, что x это 5, то, согласно логике, я не могу заявить, что x также и 6! Было бы нечестно. Поэтому функции с одинаковыми параметрами всегда должны возвращать тот же результат:\\  
x = add\_two\_to(3) = 5\\ 
$\therefore x = 5$
 
Функции, которые  всегда возвращают одинаковый результат для тех же параметров, называются чистыми. Именно поэтому мы можем заменить  \ops{add\_two\_to(3)} на 5, потому что результат операции \ops{3+2} будет всегда равен 5. Это означает, что мы можем компоновать десятки функций для решения более сложных проблем, при этом сохраняя уверенность, что ничего не сломается. Ясно и логично, не так ли? Правда, есть одна проблема:\\ 
x = today() = 2009/10/22\\ 
--- ждём один день --\\ 
x = today() = 2009/10/23\\ 
x = x\\ 
$\therefore$ 2009/10/22 = 2009/10/23 

О, нет! Мои прекрасные равенства! Они вдруг стали неверными! Как так вышло, что моя функция возвращает каждый день разные результаты?

Очевидно, существуют случаи, когда полезно не соблюдать чистоту. В Erlang очень прагматичный подход к фунциональному программированию: повинуйся принципам чистоты (пиши функции без побочных эффектов, избегай изменяемых данных и т.д.), но уходи от них, когда решаешь проблемы реального мира.

\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{envelope.png}
\end{wrapfigure}
Итак, мы определили Erlang как функциональный язык программирования, но в нём также есть большой уклон в параллелизм и высокую надёжность. Для того, чтобы иметь возможность одновременно выполнять десятки задач, Erlang использует актор\--модель, где каждый актор это отдельный процесс виртуальной машины. В двух словах, если бы вы были актором в мире Erlang, быть вам одиноким человеком, который сидит в тёмной комнате без окон рядом с почтовым ящиком и ожидает сообщений. Как только вы получаете сообщение, ваша реакция следующая: если вам пришёл счёт \--- вы его оплачиваете, если пришло поздравление с днём рождения, то вы отвечаете письмом с благодарностью, а все письма, которые вам непонятны, вы игнорируете.

Актор\--модель в Erlang можно представить как мир, где каждый сидит в своей комнатке и может исполнять несколько определённых задач. Любое общение происходит только посредством почтовой переписки. Немного скучноватая жизнь (и золотая эра для почтовых служб), но вы можете попросить нескольких людей выполнить для вас строго определённый набор задач, и никто не выполнит свою задачу неверно, не сделает ошибку, которая окажет воздействие на работу других людей. Они даже не будут предполагать о существовании кого\--то ещё, кроме вас (и это прекрасно).

Но не будем заходить с аналогией слишком далеко. Можно сказать, что Erlang заставляет вас писать акторы (процессы), которые не разделяют информацию с другими частями кода, кроме случаев, когда они посылают друг другу сообщения. Каждая коммуникация происходит явно, она безопасна и её можно проследить.
Когда мы определяли, что же такое Erlang, то делали это на языковом уровне. Но история на этом не заканчивается: Erlang в целом является ещё и средой разработки. Код компилируется в байт\--код и исполняется в виртуальной машине. Поэтому Erlang, как и Java, может исполняться где угодно. Стандартный дистрибутив включает (кроме прочего) средства разработки (компилятор, отладчик, профайлер, библиотека для unit\--тестирования), фреймворк Open Telecom Platform (OTP), веб\--сервер, парсер и базу данных mnesia \--- систему хранения пар ключ\--значение, которая способна реплицировать себя на несколько серверов, поддерживает вложенные транзакции и позволяет хранить любые данные, которые определены в Erlang.

Виртуальная машина и библиотеки также позволяют обновлять код на работающей системе, не прерывая исполнение, легко распределять код на несколько компьютеров и осуществляет простую, но эффективную обработку ошибок.

\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{letitcrash.png}
\end{wrapfigure}
Позже мы увидим как использовать эти инструменты, но сейчас я расскажу ещё об одном общем правиле Erlang: пусть процесс падает. Но пусть он падает не как самолёт в авиакатастрофе с десятками человеческих жертв, а пусть падает как канатоходец, под которым натянута страховочная сеть. Избегать ошибок, конечно же, нужно, но делать проверки на каждый тип ошибки в большинстве случаев нет необходимости.

Итак, Erlang умеет восстанавливаться после ошибок, организовывать код при помощи акторов, производить распределённое масштабирование и обеспечивать параллелизм. Но это приводит нас к следующему разделу\ldots

\section{Не забывайтесь}
В книге будет много маленьких жёлто\--оранжевых разделов, с названиями похожими на это (их легко заметить). Erlang в данный момент набирает популярность во многом благодаря пылким речам, которые могут ввести людей в заблуждение. Могут убедить, что Erlang \--- нечто большее, чем есть на самом деле. Эти напоминания помогут вам не забываться, если вы переполнены энтузиазмом сверх меры.

Первый случай такого заблуждения относится к мощным возможностям масштабирования, которые заложены в Erlang и осуществляются при помощи лёгких процессов. Да, действительно, процессы в Erlang очень легки: единовременно могут существовать сотни тысяч таких процессов, но это не означает, что они должны существовать просто потому что есть такая возможность. К примеру, вы создаёте игру\--стрелялку. Было бы безумием представлять все объекты в игре, включая пули, при помощи акторов. В такой игре вы сможете выстрелить только себе в ногу. Пересылка сообщений от акторa к актору всё\--таки отнимает ресурсы, как бы малы они ни были. Если будете дробить задачи слишком сильно, \emph{всё может сильно замедлиться}!

Я расскажу об этом подробнее, когда мы погрузимся в изучение достаточно глубоко, чтобы это нас начало беспокоить. Но пока что имейте в виду, что бездумно использовать параллелизм при решении проблемы, совсем недостаточно, для того чтобы решение стало быстрым. Не огорчайтесь! Будут и случаи, когда использовать сотни процессов можно и нужно! Просто не каждый случай \--- тот самый.

Ещё об Erlang говорят, что он может масштабироваться прямо пропорционально количеству вычислительных ядер, которые есть в вашем компьютере, но обычно это не так. Возможность такая имеется, но большинство задач не получится запустить так, чтобы всё исполнялось одновременно.
\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{scaling.png}
\end{wrapfigure}

Стоит помнить ещё об одном: хотя Erlang и делает некоторые вещи очень хорошо, всё\--таки технически возможно получить те же результаты при помощи других языков. Обратное также верно. Тщательно оценивайте проблему и выбирайте правильный инструмент, исходя из той задачи, которую вы пытаетесь решить. Erlang \--- не панацея и будет особенно плох в обработке изображений и сигналов или в качестве языка для написания драйверов. Однако он будет блистать в области большого программного обеспечения для серверов (например: очереди, map\--reduce), в вычислениях совместно с другими языками, в высокоуровневой реализации протоколов и т.д. Всё, что находится между этими полюсами, зависит лишь от вас. Не обязательно ограничивать себя только серверными вычислениями на Erlang. Были случаи, когда люди делали неожиданные и удивительные вещи. Один из примеров это IANO \--- робот, созданный командой UNICT. Они используют Erlang для реализации искусственного интеллекта и получили серебрянную медаль на соревновании eurobot в 2009 году. Ещё один пример \--- Wings 3D. Платформонезависимая программа трёхмерного моделирования (без рендерера) с открытым исходным кодом, которая написана на Erlang.

\section{Что нужно для изучения}
Всё что нужно для начала это текстовый редактор и среда Erlang. Можно загрузить исходный код и сборки для Windows с официального сайта Erlang. Не буду углубляться в детали установки, но для Windows достаточно скачать и запустить исполняемый файл. Не забудьте добавить директорию Erlang в переменную окружения PATH, чтобы получить доступ к ней из командной строки.

В Debian\--подобных Linux дистрибутивах необходимо установить пакет командой \ops{\# apt-get install erlang}. В Fedora (если установлен <<yum>>), можно проделать то же самое, набрав \ops{\# yum install erlang}. Однако, официальные репозитории обычно содержат устаревшие версии пакетов Erlang. Если вы будете использовать старую версию пакета, это может привести к расхождениям между вашим результатом и этим руководством. К тому же, в определённых приложениях производительность будет снижена. Поэтому я рекомендую вам компилировать всё из исходного кода. Изучите содержимое файла README, который поставляется с пакетом, воспользуйтесь Google для получения подробностей установки, у них это получится намного лучше, чем у меня.

В FreeBSD существует много способов установки. Если вы используете \ops{postmaster}, можно исполнить команду\\ 
\ops{postmaster lang/erlang}.\\ 
Для установки из портов вопользуйтесь командой\\ 
\ops{cd /usr/ports/lang/erlang;make install clean}.\\ 
В конце концов, если хотите воспользоваться пакетами, запустите\\  
\ops{pkg\_add -rv erlang}.\\ 
Если вы пользователь OSX, то можете установить Erlang командой\\ 
\ops{brew install erlang}\\ 
при помощи Homebrew или воспользуйтесь\\ 
\ops{port install erlang}, если предпочитаете MacPorts.\\ 
\colorbox{lgray}
{
\begin{minipage}{1.0\linewidth}
\textbf{Замечание:} на момент написания я использую Erlang версии R13B+, поэтому для наилучших результатов используйте такую же версию, либо более новую.
\end{minipage}
}
\section{Где искать помощь}
Есть несколько мест, где вам помогут. Хорошую техническую документацию можно найти в man страницах, если вы используете Linux. Например, в Erlang есть модуль lists (который мы скоро увидим): чтобы получить документацию по этому модулю напишите в консоли \ops{\$ erl -man lists}.

Инсталляция в Windows должна содержать документацию в формате HTML. Её всегда можно скачать с \href{http://erlang.org/doc/}{официального сайта Erlang} или обратиться к одному из \href{http://erldocs.com}{альтернативных сайтов}.

Как только почувствуете, что пишете что\--то не то, обратитесь к правилам хорошего кодирования, которые можно найти \href{http://www.erlang.se/doc/programming_rules.shtml}{здесь}. Код в этой книге будет стараться придерживаться этих правил.

Бывают случаи, когда простого понимания технических деталей недостаточно. Когда наступает такой момент, я обращаюсь к двум источникам знаний: официальной \href{http://www.erlang.org/static/doc/mailinglist.html}{почтовой рассылке} (там есть чему поучиться) и irc каналу \#erlang на irc.freenode.net.

А если вы любите готовые рецепты, то \href{http://trapexit.org}{trapexit} это то что вам нужно. Ещё они держат зеркало почтовой рассылки в виде форума и общую вики. Там всегда можно найти что\--нибудь полезное.

\chapter{Начинаем}
\section{Оболочка}
В Erlang можно проверить большую часть кода в эмуляторе. В нём можно запускать компилированные скрипты, но также можно редактировать код вживую. Чтобы запустить оболочку в Linux, откройте терминал и наберите \ops{\$ erl}. Если вы всё правильно настроили, появится приблизительно такой текст: 
\begin{lstlisting}[style=repl]
Erlang R13B01 (erts-5.7.2) [source] [smp:2:2] 
[rq:2] [async-threads:0] [hipe] [kernel-poll:false] 
 
Eshell V5.7.2  (abort with ^G) 
\end{lstlisting}

Поздравляю, вы запустили оболочку Erlang! 

Пользователи Windows тоже могут запустить \ops{erl.exe}, но лучше использовать \ops{werl.exe}, который можно найти в стартовом меню (\ops{programs > Erlang}). Werl это оболочка Erlang, которая существует только для Windows. Она поддерживает оформление окон с полосами прокрутки и операциями редактирования (такими, например, как копирование\--вставка, которых очень не хватает в стандартной оболочке \ops{cmd.exe} для Windows). Если вы захотите использовать перенаправление стандартного ввода\--вывода или каналы, то erl вам всё\--таки пригодится. 

Мы сможем вводить и запускать код в эмуляторе, но сначала посмотрим как с ним обращаться.
\section{Команды оболочки}
В оболочку Erlang встроено подмножество функций популярного текстового редактора Emacs, использование которого берёт начало в 70\--х годах. Если вы знакомы с Emacs, то ваших знаний будет достаточно. У всех остальных и без этих знаний всё получится.

\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{shell.png}
\end{wrapfigure}
К примеру, если напечатать какой\--либо текст и нажать \ops{\textasciicircum A}(Ctrl+A), ваш курсор переместится в начало строки. \ops{\textasciicircum E}(Ctrl+E) переносит курсор в конец строки. Чтобы перемещаться вперёд и назад, используйте клавиши со стрелками <<влево>> и <<вправо>>. Чтобы не набирать код заново, можно использовать клавиши <<вверх>> и <<вниз>>, которые воспроизводят предыдущие или последующие строки.

Если написать, к примеру, \ops{li} и нажать <<tab>>, оболочка дополнит за вас слово до \ops{lists:}. Если нажать tab ещё раз, то оболочка предложит функции, которые могут следовать за lists:. Так Erlang дополняет имя модуля lists и предлагает функции, которые тот содержит. Способ записи может показаться странным, но не переживайте, вы к нему быстро привыкнете.
Думаю, мы достаточно ознакомились с функциональностью оболочки, чтобы понимать что к чему. Кроме одного момента: мы не знаем как из неё выйти! Ответ на этот вопрос получить очень просто. Напишите \ops{help().} и вы получите описание команд, которые можно использовать в оболочке (не забудьте написать точку (\ops{\strut.}), она нужна для исполнения команды). Чуть позже мы воспользуемся некоторыми из них, но сейчас единственная строка, которая нам нужна для того, чтобы выйти из оболочки это:\\ 
\ops{q() -- quit - shorthand for init:stop()} 

Это один из способов выхода (если быть точным, то два способа). Но от этой команды мало толку, если оболочка зависла! Если вы внимательно следили за тем, что пишет оболочка при запуске, то видели комментарий о том, что можно <<прекратить исполнение при помощи \ops{\textasciicircum G}>>. Нажмём это сочетание клавиш и напечатаем h, чтобы получить подсказку.
\begin{lstlisting}[style=repl]
User switch command
--> h
c [nn]            - connect to job
i [nn]            - interrupt job
k [nn]            - kill job
j                 - list all jobs
s [shell]         - start local shell
r [node [shell]]  - start remote shell
q        - quit erlang
? | h             - this message
-->
\end{lstlisting}

Если нажать \ops{i} и следом \ops{c}, то Erlang остановит исполнение кода и возвратится в интерактивную оболочку. По нажатию \ops{j} будет выведен список запущенных процессов (звёздочка следом за номером указывает, что задача исполняется в данный момент). Процесс можно прервать, написав \ops{i} и следом номер задачи. Команда \ops{k} не прерывает оболочку, а полностью завершает её исполнение. Команда \ops{s} запускает новую оболочку.
\begin{lstlisting}[style=repl]
Eshell V5.7.2  (abort with ^G)
1> "OH NO THIS SHELL IS UNRESPONSIVE!!! *hits ctrl+G*"
User switch command
--> k
--> c
Unknown job
--> s
--> j
2* {shell,start,[]}
--> c 2
Eshell V5.7.2  (abort with ^G)
1> "YESS!"
\end{lstlisting}

Если вы полностью прочитали текст подсказки, то, возможно, заметили, что мы можем запустить удалённую оболочку. Не буду сейчас вдаваться в детали, но этот факт даёт представление о том, на что способна виртуальная машина Erlang помимо запуска кода. А теперь начнём (на этот раз по\--настоящему).
\chapter{Начинаем (по\--настоящему)} 
\label{starting_out_for_real}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
    Erlang довольно простой и компактный язык (в том же смысле, в котором C проще чем C++). В языке определены несколько фундаментальных типов данных. В этой главе мы рассмотрим их большую часть. Рекомендуется обязательно прочитать главу, так как в ней объясняются элементы необходимые для построения всех программ, которые вы позже будете писать на Erlang.
    \end{minipage}
}
\section{Числа}
В оболочке Erlang выражения должны завершаться точкой, за которой следует пробел (возврат каретки, пробел и т.д.), иначе это выражение не будет выполнено. Можно разделять выражения запятыми, но лишь результат последнего выражения отобразится на экране (однако, все остальные выражения будут всё равно исполнены). Для большинства людей этот синтаксис покажется довольно непривычным. Он восходит к тем временам, когда Erlang был реализован на Prolog \--- языке логического программирования.

Откройте оболочку Erlang так, как мы это делали в предыдущей главе, и давайте\--ка что\--нибудь попечатаем!
\begin{lstlisting}[style=repl]
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472.
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
\end{lstlisting}

Возможно вы заметили, что для Erlang не имеет значения, вводите вы дробные числа или целые: в арифметических операциях поддерживаются оба типа. Целые и дробные значения это, в общем\--то, единственные типы данных, которые будут прозрачно обрабатываться математическими операторами Erlang. Однако, если вы хотите делить целое на целое \--- используйте \ops{div}, а для операции взятия остатка по модулю используйте оператор \ops{rem}(remainder, остаток).

Обратите внимание, что мы можем использовать несколько операторов в одном выражении, и порядок вычисления арифметических операций подчиняется обычным правилам.
\begin{lstlisting}[style=repl]
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
\end{lstlisting}

Если хотите выразить целое число в системе счисления с основанием отличным от 10, то просто введите его в виде \ops{Основание\#Число} (основание может меняться в диапазоне 2\ldots36):
\begin{lstlisting}[style=repl]
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
\end{lstlisting}

Прекрасно! Erlang обладает возможностями калькулятора, который пылится где\--то в дальнем углу вашего стола. Вдобавок, у калькулятора весьма странный синтаксис! Просто великолепно!
\section{Неизменные переменные}
\label{invariable_variables}
Арифметические вычисления это отлично, но без возможности сохранять промежуточные результаты далеко не уедешь. Для этого мы будем использовать переменные. Если вы прочитали введение к этой книге, то знаете, что переменные в функциональном программировании не могут меняться. Общее поведение переменных можно продемонстрировать в следующих 7 выражениях (обратите внимание, что имена переменных начинаются с заглавной буквы):
\begin{lstlisting}[style=repl]
1> One.
* 1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
\end{lstlisting}

Первое, что можно заметить: значение можно присваивать переменной ровно один раз, после этого можно <<притвориться>>, что вы присваиваете значение, только если это то же самое значение, которое ей уже присвоено. Erlang\--у не понравится, если они будут различны. Объяснение кроется в свойствах оператора \ops{\strut=}. Оператор \ops{\strut=} (не переменные) выполняет функцию сравнения значений и сообщает, если они отличаются. Если они одинаковы, то оператор просто возвращает значение:
\begin{lstlisting}[style=repl]
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
\end{lstlisting}

Оператор в сочетании с переменными делает следующее: если выражение слева \--- свободная переменная (с ней не связано значение), Erlang автоматически свяжет значение, которое находится справа, с переменной слева. После этого сравнение завершится успешно, и значение переменной сохранится в памяти.

Такое поведение оператора \ops{\strut=} это основа <<сопоставления с образцом>> (pattern matching), которое существует во многих функциональных языках программирования, хотя его реализация в Erlang обычно считается более гибкой и полной в сравнении с аналогами. Мы рассмотрим сопоставление с образцом более детально, когда будем разбираться с кортежами и списковыми типами, чуть позже в этой же главе, а также в связи с функциями в последующих главах.

Ещё один факт, который можно почерпнуть из команд 1\--7 это то, что имена переменных должны начинаться с заглавной буквы. Команда 7 завершилась ошибкой, потому что слово \emph{two} начинается со строчной буквы. Имена переменных технически могут начинатся со знака подчёркивания ('\_'), но по соглашению такие имена используются только для переменных, значение которых вас не интересует, но вы всё\--таки посчитали, что было бы неплохо описать, что же в них содержится.

Ещё можно завести переменную, имя которой будет состоять просто из знака подчёркивания:
\begin{lstlisting}[style=repl]
10> _ = 14+3.
17
11> _.
* 1: variable '_' is unbound
\end{lstlisting}

В отличие от любой другой переменной, у этой никогда не будет собственного значения. На данный момент это для нас абсолютно бесполезно, но запомним, что такая переменная существует. Она нам ещё пригодится.\\ 
\colorbox{lgray}
{
\begin{minipage}{1.0\linewidth}
\textbf{Замечание:} если вы экспериментируете в оболочке и присвоили переменной неверное значение, то можно <<удалить>> эту переменную при помощи функции \ops{f(Variable).}. Чтобы очистить все переменные, используйте \ops{f().}.
\par 
Эти функции работают только в оболочке и созданы специально, чтобы помогать вам во время тестирования. В настоящих программах мы не сможем удалять значения таким способом. Смысл этого поведения становится понятен, если представить Erlang в производственном окружении: вполне возможно, что оболочка будет непрерывно запущена на протяжении нескольких лет\ldots Готов поспорить, что переменная X будет использована за это время больше одного раза.
\end{minipage}
}
\section{Атомы}
\label{atoms}
Атомы являются причиной, по которой имена переменных должны начинаться с заглавной буквы. Атомы это литералы \--- константы с собственным именем для некоторого значения. Атомы это только то, что вы видите и больше ничего в них нет. Атом \emph{cat} просто означает <<cat>> и ничего больше. С ним нельзя поиграть, его нельзя изменить, его нельзя разбить вдребезги; это \emph{cat}. Cмиритесь с этим.

Кроме записи атомов в виде слов, которые начинаются со строчной буквы, существует ещё несколько способов записи:
\begin{lstlisting}[style=repl]
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom
\end{lstlisting}

Если атом не начинается со строчной буквы или содержит символы отличные от букв и цифр, знака подчёркивания (\_) или @, то он должен обрамляться одиночными кавычками ('). Выражение под номером 5 также показывает, что атом, заключённый в одиночные кавычки, это совершенно то же самое, что и атом без них.

\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{atom.png}
\end{wrapfigure}
Я сравнил атомы с константами, у которых значением является их собственное имя. Возможно, вы раньше работали с кодом, в котором использовались константы. Например, пусть у меня есть значения, которые соответствуют цвету глаз: \ops{BLUE -> 1, BROWN -> 2,} \ops{GREEN -> 3, OTHER -> 4}. Необходимо сопоставить имя константы с некоторым значением. Атомы позволяют без этого обойтись. Цвет глаз может просто быть 'blue', 'brown', 'green' и 'other'. Эти цвета можно использовать в коде где угодно: значения никогда не пересекутся, и, к тому же, такая константа всегда инициализирована. Если вам в самом деле нужны именно константы со связанными значениями, то всё\--таки существует способ их получить. Мы рассмотрим его в главе~\ref{modules}.

Таким образом, атом хорош для того, чтобы представлять данные, которые с ним связаны. Без данных довольно сложно найти ему достойное применение. Довольно об атомах. Их время настанет, когда мы сможем компоновать их с другими типами данных.\\ 
\colorbox{lorange}
{
    \begin{minipage}{1.0\linewidth}
\textbf{Не забывайтесь:}

Атомы прекрасно подходят для отсылки сообщений и представления констант. Но во многих случаях использование атомов скрывает подвох. Обращение к атому происходит через <<таблицу атомов>>, которая занимает память (4 байт/атом в 32\--битной системе, 8 байт/атом в 64\--битной системе). Таблица атомов не обрабатывается сборщиком мусора, поэтому атомы будут накапливаться до тех пор, пока система не остановится из\--за нехватки памяти, либо потому что было определено максимальное количество атомов \--- 1048577.

Поэтому атомы нельзя генерировать динамически ни в коем случае. Если вам нужна надёжная система, но данные, введённые пользователем, роняют её из\--за конвертации ввода в атомы, то у вас серьёзные проблемы. Атомы необходимо рассматривать только как инструменты разработчика, потому что на самом деле они как раз ими и являются.
\end{minipage}
}
\colorbox{lgray}{
    \begin{minipage}{1.0\linewidth}
    \textbf{Замечание:} некоторые атомы являются зарезервированными словами и их нужно использовать так, как было задумано разработчиками языка: для обозначения имён функций, операторов, выражений и т.д. Вот эти атомы: \ops{after and andalso band begin}
\ops{bnot bor bsl bsr bxor case catch}
\ops{cond div end fun if let not of}
\ops{or orelse query receive rem try when xor}
\end{minipage}
}
\section{Булева алгебра и операторы сравнения}\label{boolandcompare}
\begin{wrapfigure}[7]{r}{0.20\linewidth}
    \includegraphics[width=1.0\linewidth]{boole.png}
\end{wrapfigure}
Если бы человек не мог отличать большое от малого, истину от лжи, то ему бы пришлось нелегко. В Erlang, как и в любом другом языке, есть возможность применения булевых операций и сравнения элементов.
Булева алгебра очень проста:\\ 
\begin{lstlisting}[style=repl]
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
\end{lstlisting} 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Замечание:} Операторы \ops{and} и \ops{or} всегда вычисляют аргументы, находящиеся по обе стороны от оператора. Если вам нужны операторы, которые вычисляют правую сторону только при необходимости, используйте \ops{andalso} и \ops{orelse}.
    \end{minipage}
} 

Проверка на равенство и неравенство тоже выполняется очень просто, но при этом используют несколько другие символы, чем те, которые можно увидеть во многих других языках:
\begin{lstlisting}[style=repl]
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
\end{lstlisting}

Во\--первых, если в привычном языке для проверки на равенство и неравенство используется \ops{==} и \ops{!=}, то в Erlang используется \ops{=:=} и \ops{=/=}. Три последних выражения (строки с 9 по 11) также знакомят нас с ловушкой: Erlang не делает различий при выполнении арифметических действий между целыми числами и числами с плавающей запятой, но он будет различать эти числа при сравнении. Впрочем, беспокоиться не о чем, потому что в этом случае придут на помощь операторы \ops{==} и \ops{/=}. Помните об этом различии на случай, если понадобится сравнить числа, не сравнивая их типы.

Остальные операторы сравнения: \ops{$<$} (меньше чем), \ops{$>$} (больше чем), \ops{$>=$} (больше либо равно) и \ops{$=<$} (меньше либо равно). Мне кажется, что последний оператор записывается задом\--наперёд, и из\--за него в моём коде появляется много синтаксических ошибок. Будьте внимательны с этим \ops{$=<$}.
\begin{lstlisting}[style=repl]
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
\end{lstlisting}

Как узнать что происходит, если выполнить \ops{5 + llama} или \ops{5 == true}? Нет способа лучше, чем исполнить эти выражения и испугаться сообщений об ошибках!
\begin{lstlisting}[style=repl]
12> 5 + llama.
** exception error: bad argument in an arithmetic expression
    in operator  +/2
        called as 5 + llama
\end{lstlisting}

Ну что сказать? Erlang не нравится, что вы неправильно используете его базовые типы! Здесь эмулятор возвращает вполне понятное сообщение об ошибке. Он сообщает, что ему не по нраву один из аргументов, которые окружают оператор \ops{+}!

Впрочем, Erlang сердится из\--за неверных типов не всегда по делу:
\begin{lstlisting}[style=repl]
13> 5 =:= true.
false
\end{lstlisting}

Почему для некоторых операторов различия в типах не существено, а для других имеет значение? Хотя Erlang не разрешает суммировать что попало с чем угодно, он позволяет \emph{сравнивать}. Так получилось потому, что создатели Erlang посчитали, что прагматизм стоит выше теории и решили, что было бы неплохо иметь возможность писать, к примеру, общие алгоритмы сортировки, которые могли бы упорядочивать любые элементы. В большинстве случаев это делает жизнь проще.

Когда работаете с булевой алгеброй и сравнениями, стоит помнить ещё об одной вещи:
\begin{lstlisting}[style=repl]
14> 0 == false.
false
15> 1 < false.
true
\end{lstlisting}

Если вы раньше имели дело преимущественно с процедурными или объектно\--ориентированными языками, то, вероятно, сейчас рвёте волосы на голове. Строка 14 должна возвращать \emph{true}, а строка 15 \emph{false}! Везде false означает 0, а true это всё остальное! Но не в Erlang. Потому что я вам солгал. Да, я вам наврал. Стыд мне и позор.

В Erlang нет такого понятия как булевы значения \emph{true} и \emph{false}. Элементы true и false на самом деле являются атомами, но они хорошо интегрированы в язык, и проблем с ними не будет, пока вы будете считать, что false и true не значит ничего кроме false и true.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
    \textbf{Замечание:} при сравнении элементы выстроены в следующем порядке:\\ 
    \ops{number < atom < reference < fun < port < pid < tuple < list < bit string} 
    
    Все эти понятия вам пока неизвестны, но вы будете с ними знакомиться по мере продвижения по тексту книги. Просто помните, что именно поэтому вы можете сравнивать что угодно с чем угодно! Процитирую Joe Armstrong, одного из создателей Erlang: <<Важен не сам порядок, а то, что этот порядок чётко определён.>>
    \end{minipage}
}
\section{Кортежи}
Кортеж это способ организации данных. С его помощью можно сгруппировать элементы, когда вам известно их количество. Кортежи в Erlang записываются следующим образом: \ops{\{Element1, Element2,\ldots, ElementN\}}. Как пример можно привести координаты (x, y), которые задают точку на плоскости. Мы можем представить координаты как кортеж двух элементов:
\begin{lstlisting}[style=repl]
1> X = 10, Y = 4.
4
2> Point = {X,Y}.
{10,4}
\end{lstlisting}

В этом случае точка будет всегда представлена двумя элементами. Вместо того, чтобы всюду таскать за собой переменные X и Y, можно определить всего одну. Но что же делать, если у меня есть переменная\--точка, а мне необходима лишь её X координата? Эту информацию можно легко извлечь. Помните, когда мы присваивали значения переменным, Erlang никогда не выражал недовольство, если присваиваемые значения были равны содержимому переменных. Давайте это используем! Возможно, вам нужно будет очистить уже определённые переменные командой \ops{f()}.
\begin{lstlisting}[style=repl]
3> Point = {4,5}.
{4,5}
4> {X,Y} = Point.
{4,5}
5> X.
4
6> {X,_} = Point.
{4,5}
\end{lstlisting}
\begin{wrapfigure}{l}{0.3\textwidth}
    \includegraphics[width=1.0\linewidth]{mr-brackets.png}
\end{wrapfigure}

Теперь мы можем использовать \emph{X}, чтобы получать первое значение в кортеже! Как так получилось? Сначала \emph{X} и \emph{Y} не имели значения, и поэтому считались свободными переменными. Когда мы поместили их в кортеж \emph{\{X, Y\}} по левую сторону оператора \ops{=}, оператор \ops{=} сравнивает оба значения: \emph{\{X, Y\}} и \emph{\{4, 5\}}. У Erlang хватает сообразительности, чтобы распаковать значения в кортеже и распределить их по свободным переменным слева от оператора присваивания. После этого сравнение приходит к виду \ops{\{4, 5\} = \{4, 5\}}, и, очевидно, завершается успехом! Это одна из многих форм операции сопоставления с образцом (pattern matching).

Заметьте, что в шестом выражении я использовал анонимную переменную \_. Она должна использоваться именно в таких случаях: когда необходимо отбросить значение, которое нам не понадобится. Переменная \_ всегда определена как свободная и служит элементом подстановки (wildcard) для сопоставления с образцом. Для распаковки кортежей сопоставление с образцом будет работать лишь в том случае, когда количество элементов (длина кортежа) с обеих сторон одинаковое.
\begin{lstlisting}[style=repl]
7> {_,_} = {4,5}.
{4,5}
8> {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}
\end{lstlisting}

Также кортежи полезны при работы с одиночными значениями. В каком смысле? Простейший пример, температура:
\begin{lstlisting}[style=repl]
9> Temperature = 23.213.
23.213
\end{lstlisting}

В такой денёк неплохо было бы пойти на пляж\ldots Погодите\--ка, это температура по шкале Кельвина, Цельсия или Фаренгейта?
\begin{lstlisting}[style=repl]
10> PreciseTemperature = {celsius, 23.213}.
{celsius,23.213}
11> {kelvin, T} = PreciseTemperature.
** exception error: no match of right hand side value {celsius,23.213}
\end{lstlisting}

Операция вызывает ошибку, но это как раз то, чего мы хотим! Мы снова наблюдаем в работе сопоставление с образцом. Оператор \ops{=} сравнивает \emph{\{kelvin, T\}} и \emph{\{celsius, 23.213\}}. Не смотря на то, что переменная T свободна, Erlang при сравнении не посчитает атом \emph{celsius} идентичным атому \emph{kelvin}. Будет брошено исключение, которое остановит выполнение кода. Благодаря этому та часть нашей программы, которая ожидает температуру по шкале Кельвина, не сможет обработать температуру, которая будет представлена в градусах Цельсия. Это помогает программисту знать, какие данные передаются, и помогает отлаживать код. Кортеж, который содержит атом и следом за ним одиночный элемент, называется <<меченым кортежем>>. Любой элемент кортежа может быть любого типа. Он может быть даже ещё одним кортежем:
\begin{lstlisting}[style=repl]
12> {point, {X,Y}}.
{point,{4,5}}
\end{lstlisting}

Что же делать, если нам нужно работать с несколькими точками?
\section{Списки!}
\label{lists}
Списки \--- это основа многих функциональных языков. Их используют для решения различных проблем, и они, несомненно, являются наиболее используемой структурой данных в Erlang. Списки могут содержать всё что угодно! Числа, атомы, кортежи, другие списки \--- ваши самые дикие мечты в одной структуре. Основной способ записи для списков: \ops{[Element1, Element2,\ldots,ElementN]}, и в них можно смешивать несколько разных типов данных:
\begin{lstlisting}[style=repl]
1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
\end{lstlisting}

Всё просто, не так ли?
\begin{lstlisting}[style=repl]
2> [97, 98, 99].
"abc"
\end{lstlisting}

Ой\--ой! Это одна из самых нелюбимых вещей в Erlang: строки! Строки \--- это тоже списки, поэтому записываются они абсолютно так же! Почему люди их не любят? Вот почему:
\begin{lstlisting}[style=repl]
3> [97,98,99,4,5,6].
[97,98,99,4,5,6]
4> [233].
"é"
\end{lstlisting}

Erlang напечатает список чисел в виде чисел, только если хотя бы одно из них нельзя представить в виде буквы! Настоящих строк В Erlang просто нет! Вне всякого сомнения этот факт будет вас преследовать, и из\--за него вы возненавидите язык. Но не отчаивайтесь \--- есть и другие способы записи строк, с которыми мы познакомимся чуть позже в этой главе.\\ 
\colorbox{lorange}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Не забывайтесь:}\\ 
        Возможно, вы слышали, что Erlang плохо подходит для манипуляций со строками, потому что в нём нет встроенных строк, в отличие от большинства других языков. Произошло это потому, что Erlang был создан и использовался в телекоммуникационных компаниях. Они никогда (или редко) не использовали строки, и поэтому им никогда не приходило в голову официально добавить их в язык. Тем не менее, недостатки Erlang в области строковых преобразований со временем устраняются. Виртуальная машина имеет встроенную поддержку Unicode\--строк, и в целом операции со строками постоянно ускоряются.
        
        Строки также можно хранить в виде двоичной структуры данных, что увеличивает эффективность хранения и скорость обработки. Но всё же стандартной библиотеке не хватает некоторых функций. И, хотя в Erlang совершенно точно можно работать со строками, но для задач, в которых нужно делать много строковых преобразований, лучше подходят другие языки, например Perl или Python.
    \end{minipage}
}

Для склейки списков используют оператор\ops{++}. Противоположное действие выполняет оператор \ops{$--$}, который удаляет элементы из списка:
\begin{lstlisting}[style=repl]
5> [1,2,3] ++ [4,5].
[1,2,3,4,5]
6> [1,2,3,4,5] -- [1,2,3].
[4,5]
7> [2,4,2] -- [2,4].
[2]
8> [2,4,2] -- [2,4,2].
[]
\end{lstlisting}

Оба оператора, \ops{++} и \ops{$--$} \--- ассоциативны справа. Это означает, что элементы нескольких последовательных операций \ops{++} и \ops{$--$} будут обрабатываться справа налево как в следующем примере:
\begin{lstlisting}[style=repl]
9> [1,2,3] -- [1,2] -- [3].
[3]
10> [1,2,3] -- [1,2] -- [2].
[2,3]
\end{lstlisting}

Продолжим. Первый элемент списка называется Головой (головным элементом), остальные элементы списка называются Хвостом (хвостовыми элементами). Для их получения будем использовать две встроенные функции:
\begin{lstlisting}[style=repl]
11> hd([1,2,3,4]).
1
12> tl([1,2,3,4]).
[2,3,4]
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Замечание:} встроенными обычно называют функции (ВФ), которые невозможно реализовать на чистом Erlang, поэтому они реализованы на С или любом другом языке, на котором реализован Erlang (в 80\--х это был Prolog). Есть также и ВФ, которые можно реализовать на Erlang, но их всё равно пишут на С, для увеличения скорости исполнения часто используемых операций. Как пример можно привести функцию \ops{length(List)}, которая (как вы, наверное, догадались) возвращает длину списка, который был передан ей в качестве аргумента.
    \end{minipage}
}

Операция доступа к головному элементу или добавления к голове списка выполняется быстро и эффективно. Практически во всех случаях, в которых вы сталкиваетесь со списками, вам нужно выполнять операции с заголовком списка. Из\--за того, что эта операция используется так часто, существует более простой метод отделения заголовка от хвоста, при помощи сопоставления с образцом: \ops{[Head|Tail]}. Вот так можно добавить новый элемент в голову списка:
\begin{lstlisting}[style=repl]
13> List = [2,3,4].
[2,3,4]
14> NewList = [1|List].
[1,2,3,4]
\end{lstlisting}

При обработке списка неплохо было бы иметь быстрый способ хранить хвост, чтобы позже иметь возможность его обрабатывать. Если вы помните как работают кортежи, и как мы использовали сопоставление с образцом для распаковки значений в точку (\emph{\{X, Y\}}), то вы знаете, что мы можем очень похожим методом извлечь первый элемент (заголовок).
\begin{lstlisting}[style=repl]
15> [Head|Tail] = NewList.
[1,2,3,4]
16> Head.
1
17> Tail.
[2,3,4]
18> [NewHead|NewTail] = Tail.
[2,3,4]
19> NewHead.
2
\end{lstlisting}

Оператор \ops{|} называется cons\--оператором (конструктором). Любой список можно построить при помощи cons\--оператора и значений:
\begin{lstlisting}[style=repl]
20> [1 | []].
[1]
21> [2 | [1 | []]].
[2,1]
22> [3 | [2 | [1 | []] ] ].
[3,2,1]
\end{lstlisting}

Таким образом, любой список можно построить по следующей формуле: \ops{[Term1| [Term2 | [\ldots | [TermN]]]]\ldots}. Следовательно, списки можно определить рекурсивно как заголовок, за которым следует хвост, который, в свою очередь является заголовком, за которым следуют другие заголовки. В этом смысле можно представить список в виде земляного червя: можно разрубить его пополам, и вот у вас уже два червя.

\begin{figure}[h!]
    \includegraphics[width=0.5\textwidth]{worm.png}
\end{figure} 

Способ, при помощи которого строятся списки в Erlang, иногда немного озадачивает людей, которые не имели дело с подобными конструкторами. Чтобы немного привыкнуть к этой записи, попробуйте прочитать следующие примеры (подсказка: все они равнозначны друг другу):\\ 
\begin{lstlisting}[style=repl]
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
\end{lstlisting}

Если вам понятна эта концепция, то будут понятны и списочные выражения.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \emph{Замечание:} при использовании формы \ops{[1 | 2]} мы получаем так называемый <<неправильный список>>. Неправильные списки будут работать в сопоставлении с образцом вида \ops{[Head|Tail]}, но с ними не будут работать стандартные функции Erlang (даже \ops{length()}). В этих операциях Erlang ожидает правильные списки. У правильных списков последним элементом стоит пустой список. Когда мы объявляем список способом \ops{[2]}, то автоматически формируется правильный список. Поэтому запись \ops{[1|[2]]} сработает! Хотя неправильные списки синтаксически верны, их редко используют где\--то ещё, кроме пользовательских структур данных.
    \end{minipage}
}
\section{Списочные выражения}
Списочные выражения это способ формировать или менять списки. Программы, в которых используются списочные выражения, намного короче и проще для понимания. Этот способ основан на идее записи математических множеств; если вы когда\--либо занимались теорией множеств, или сталкивались с математической записью, то наверняка знаете как это работает. Мы задаём множество через определение свойств, которым должны удовлетворять его элементы. Сначала списочные выражения могут показаться немного сложными, но усилия, потраченные на их понимание, стоят того. С их помощью код становится чище и короче, поэтому вводите примеры и пытайтесь их понять!

Приведём пример математической записи множества: $\{x \in 
\mathbb{R}: x = x^2\}$. Эта запись говорит о том, что хотите получить действительные числа, которые равны собственному квадрату. Результатом будет множество $\{0, 1\}$. В качестве примера более простой записи можно привести \ops{\{x : x $>$ 0\}}. В результате мы должны получить все числа больше 0.

Списочные выражения в Erlang можно представить как построение множеств из других множеств. Пусть нам дано множество \ops{\{2n : n in L\}}, где L это список $[1, 2, 3, 4]$. В Erlang это можно записать как:\\ 
\begin{lstlisting}[style=repl]
1> [2*N || N <- [1,2,3,4]].
[2,4,6,8]
\end{lstlisting}

Если сравнить математическую запись с записью в Erlang, то можно заметить, что они не так уж сильно различаются: фигурные скобки (\{\}) становятся квадратными ([]), двоеточие (:) становится двумя вертикальными чертами (||), а слово <<in>> переходит в символ стрелки ($<-$). Мы просто заменяем символы, но логика остаётся прежней. В примере, приведённом выше, каждое значение $[1, 2, 3, 4]$ последовательно помещается в N (проводится операция сопоставления с образцом для каждого значения в списке). Стрелка выполняет ту же функцию, что и оператор\ops{=}, с тем лишь отличием, что она не бросает исключения.

Также в списочные выражения можно добавлять ограничивающие условия, используя операции, которые возвращают булевы значения. Если нам понадобились чётные числа от единицы до десяти, мы можем записать что\--то вроде:
\begin{lstlisting}[style=repl]
2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
\end{lstlisting}

Где конструкция \ops{X rem 2 =:= 0} проверяет число на чётность. Практическая польза этого подхода становится ясна, когда нам нужно применить функцию к каждому элементу списка или наложить на элементы какие\--либо ограничения и т.д. К примеру, мы владеем рестораном. Входит посетитель, видит наше меню и спрашивает, может ли он получить цены всех блюд, которые стоят от \$3 до \$10, включая налоги (скажем, 7\%), и налог должен быть применён после сравнения.
\begin{lstlisting}[style=repl]
3> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
[{steak,5.99},
    {beer,3.99},
    {poutine,3.5},
    {kitten,20.99},
{water,0.0}]
4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
[{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]
\end{lstlisting}

Конечно, неплохо было бы округлить числа, для улучшения читаемости, но вы поняли в чём смысл. Таким образом, списочные выражения в Erlang готовят по следующему рецепту: \ops{NewList = [Expression || Pattern}\\ 
\ops{ $<-$ List, Condition1, Condition2, ... ConditionN]}. Элемент \ops{Pattern $<-$ List} называется Генератором. И их может быть несколько!\\ 
\begin{lstlisting}[style=repl]
5> [X+Y || X <- [1,2], Y <- [2,3]].
[3,4,4,5]
\end{lstlisting}

Это выражение выполняет следующие операции: \ops{1 + 2},\ops{1 + 3},\ops{2 + 2},\ops{2 + 3}. Так что в обобщённом виде вы получите: \ops{NewList = }\\ 
\ops{[Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN,}\\ 
\ops{Condition1, Condition2, ... ConditionM]}. Обратите внимание, что выражения\--генераторы можно комбинировать с методом сопоставления с образцом и использовать в качестве фильтра:
\begin{lstlisting}[style=repl]
6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
    {montreal,storms},
    {london,fog},
    {paris,sun},
    {boston,fog},
{vancouver,snow}]
7> FoggyPlaces = [X || {X, fog} <- Weather].
[london,boston]
\end{lstlisting}

Если элемент списка <<Weather>> не совпадает с образцом \{X, fog\}, то в списочном выражении он просто игнорируется, тогда как при использовании с оператором \ops{=} было бы выброшено исключение.

Остался ещё один основной тип данных, который мы должны рассмотреть. В Erlang встроена функциональность, которая легко и просто позволяет преобразовывать двоичные данные.
\section{Битовый синтаксис!}
Во многих языках есть поддержка манипуляций с числами, атомами, кортежами, списками, записями и/или структурами и т.д. Большинство этих языков содержат очень грубые методы манипулирования двоичными данными. Erlang старается предоставить полезные абстракции для работы с двоичными данными при помощи усовершенствованного сопоставления с образцом. Это превращает работу с сырыми двоичными данными в весёлое и простое (я не вру) занятие. Метод был создан для решения телекоммуникационных задач. Битовые манипуляции предоставляют уникальный синтаксис и идиомы, которые на первый взгляд могут показаться странными, но обретают смысл, если вы имеете представление о том, как устроены биты и байты. \textbf{В противном случае вам лучше пропустить остаток этой главы.}

Согласно битовому синтаксису, двоичные данные обрамляются символами $<<$ и $>>$, и их разделяют на читаемые сегменты при помощи запятых. Сегмент \--- это последовательность бит в двоичном виде (не обязательно с выравниванием по границе байта, но такое выравнивание происходит по умолчанию). Представим, что мы хотим хранить пиксель оранжевого цвета в 24\--битном представлении. Если вам приходилось когда\--либо сталкиваться с цветовым представлением в Photoshop или в CSS, вам должна быть знакома запись в формате \#RRGGBB. Оранжевый оттенок можно записать как \emph{\#F09A29}. Erlang преобразует эту запись в следующий вид:
\begin{lstlisting}[style=repl]
1> Color = 16#F09A29.
15768105
2> Pixel = <<Color:24>>.
<<240,154,41>>
\end{lstlisting}

Это означает что\--то вроде: <<Расположи двоичное представление числа \emph{\#F09A29} в 24\--х битах (Красный в 8 битах, Зелёный в 8 и Синий тоже в 8 битах) переменной Pixel>>. Значение можно будет позже взять и в неизменном виде записать в файл. На первый взгляд ничего особенного в этом нет, но если вы откроете записанный файл в текстовом редакторе, то увидите лишь несколько нечитаемых символов. Если этот файл считать при помощи Erlang, то его содержимое в двоичном представлении будет снова преобразовано в удобный формат \emph{$<<$240,151,41$>>$}!

Но ещё интереснее то, что для распаковки двоичных данных можно использовать сопоставление с образцом:
\begin{lstlisting}[style=repl]
3> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
4> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,64,76,32,76,
0,0,234,32,15>>
5> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
\end{lstlisting}

В 3\--й команде мы определили значение, которое соответствует двоичному представлению 4\--х пикселов в RGB пространстве. В 4\--м выражении мы попытались распаковать 4 значения из двоичной величины. В результате было выброшено исключение, так как в исходной величине не 4 сегмента, а 12! Поэтому мы говорим Erlang, что каждая переменная слева будет содержать 24 бита. Именно это и означает запись \ops{Var:24}. Далее мы можем взять первый пиксел и распаковать его в отдельные цветовые компоненты:
\begin{lstlisting}[style=repl]
6> <<R:8, G:8, B:8>> = <<Pix1:24>>.
<<213,45,132>>
7> R.
213
\end{lstlisting}

<<Да, вышло неплохо. А что если мне нужен лишь первый компонент? Мне всё равно придётся постоянно распаковывать все значения?>> Ха! Прочь сомнения! Erlang приходит на помощь, комбинируя синтаксический сахар и сопоставления с образцом:
\begin{lstlisting}[style=repl]
8> <<R:8, Rest/binary>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
9> R.
213
\end{lstlisting}

Неплохо, да? А всё потому что Erlang воспринимает несколько способов описания двоичного сегмента. Можно использовать все перечисленные ниже:

Value

Value:Size

Value/TypeSpecifierList

Value:Size/TypeSpecifierList

где Size указывает количество бит, а TypeSpecifierList обозначает одно или несколько понятий из следующего списка:

\begin{minipage}{\textwidth}
\textbf{Тип}\\ 
Возможные значения: \ops{integer | float | binary | bytes | bitstring | bits | utf8}\\ 
\ops{| utf16 | utf32}\\  
Так определяется вид используемых двоичных данных. Заметьте, что 'bytes' это сокращение для 'binary', а 'bits'\--- сокращение для 'bitstring'. Если тип не задан, Erlang использует тип 'integer'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Знак}\\ 
    Возможные значения: \ops{signed | unsigned}\\ 
    Имеет значение только при сопоставлении, когда тип \--- integer. По умолчанию используется 'unsigned'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Порядок байтов}\\ 
    Возможные значения: \ops{big | little | native}\\ 
    Порядок байтов имеет значение, когда задан тип integer, utf16, utf32 или float. От порядка зависит то, как система считывает двоичные данные. Например, заголовок изображения в формате BMP содержит размер файла в виде 4\--байтного целого числа. Пусть размер файла равен 72 байта, тогда little\--endian система представит его в виде \ops{$$<<$$72,0,0,0$$>>$$}, а big\--endian система в виде \ops{$$<<$$0,0,0,72$$>>$$}. Первое будет прочитано как '72', а второе как '1207959552', поэтому старайтесь чтобы порядок байтов был верным. Также существует опция 'native', которая устанавливает порядок байт, используемый процессором. По умолчанию используется порядок байт 'big'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Единичный элемент}\\ 
    Записывается как \ops{unit:Integer}\\ 
    Это размер каждого сегмента в битах. Допустимый диапазон 1..256. По умолчанию равен 1 для integer, float, битовых строк и 8 для двоичных данных. Для типов utf8, utf16 и utf32 единицы определять не нужно. Произведение Размера на Единичный элемент равно количеству бит, которые занимает сегмент и должно быть кратным 8. Задание размера элемента часто используется для выравнивания по границе байта.\\  
\end{minipage}

Список TypeSpecifierList строится из атрибутов, разделённых символом '\--'.\\ 

Несколько примеров помогут разобраться в определениях:
\begin{lstlisting}[style=repl]
10> <<X1/unsigned>> =  <<-44>>.
<<"Ô">>
11> X1.
212
12> <<X2/signed>> =  <<-44>>. 
<<"Ô">>
13> X2.
-44
14> <<X2/integer-signed-little>> =  <<-44>>.
<<"Ô">>
15> X2.
-44
16> <<N:8/unit:1>> = <<72>>.
<<"H">>
17> N.
72
18> <<N/integer>> = <<72>>.
<<"H">>
19> <<Y:4/little-unit:8>> = <<72,0,0,0>>.     
<<72,0,0,0>>
20> Y.
72
\end{lstlisting}

Очевидно, что существует несколько способов читать, хранить и интерпретировать двоичные данные. Немного сбивает с толку, но всё же это намного проще, чем обычные инструменты, которые предоставляет большинство языков.

В Erlang также существуют стандартные битовые операции (побитовый сдвиг влево и вправо, битовое 'и', 'или', 'исключающее или' и 'не'). Они реализованы функциями \ops{bsl} (Bit Shift Left (битовое смещение влево)), \ops{bsr} (Bit Shift Right (битовое смещение вправо)), \ops{band}, \ops{bor},\ops{bxor}, и \ops{bnot}.
\begin{lstlisting}[style=repl]
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
\end{lstlisting}

С такой записью и с таким битовым синтаксисом задача парсинга и сопоставления с образцом двоичных данных сильно облегчается. К примеру, таким кодом можно распарсить сегменты TCP пакета:
\begin{lstlisting}[style=repl]
<<SourcePort:16, DestinationPort:16,
AckNumber:32,
DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
CheckSum: 16, UrgentPointer:16,
Payload/binary>> = SomeBinary.
\end{lstlisting}

Ту же самую логику можно применять к любым двоичным данным: кодированное видео, изображения, реализация стороннего протокола и т.д.\\ 
\colorbox{lorange}
{
    \begin{minipage}{\linewidth}
        \textbf{Не забывайтесь:}\\ 
        Erlang, по сравнению с С и С++, язык медленный. Чтобы заниматься чем\--нибудь вроде конвертации видео или изображений на Erlang, нужно быть терпеливым человеком, хоть применение битового синтаксиса и делает эти задачи чрезвычайно интересными, о чём я намекнул чуть выше. Erlang просто не очень хорош для тяжёлых вычислительных задач.\\ 
        Но имейте в виду, что Erlang весьма быстр там, где не нужно постоянно молотить числа: реагирование на события, передача сообщений (здесь весьма кстати приходятся чрезвычайно лёгкие атомы) и т.д. Erlang может реагировать на события в сроки измеряемые миллисекундами, и поэтому прекрасно годится для применения в задачах мягкого реального времени (soft real time).\\ 
    \end{minipage}
}

\begin{wrapfigure}{r}{0.05\textwidth}
    \includegraphics[width=1\linewidth]{string.png}
\end{wrapfigure}

Для битовой записи также существует совершенно другое приложение: битовые строки. Они не были задуманы как часть языка при проектированиию. Их <<навесили>> позже, как и строки реализованные в виде списков. Но они намного эффективнее строковых списков в отношении занимаемого пространства. Происходит это потому, что обычные списки реализованы как связные списки (1 <<узел>> на каждую букву), а битовые строки больше похожи на массивы в языке C. Для битовых строк используется синтаксис \ops{$<<$``this is a bit string!''$>>$}. Недостатком битовых строк в сравнении со списками является потеря простоты в операциях сопоставления с образцом и в строковых манипуляциях. По этой причине люди используют битовые строки для хранения текста, который не будет интенсивно меняться, либо в случаях, когда необходимо эффективно использовать память.\\ 
\colorbox{lgray}{
    \begin{minipage}{\linewidth}
        \textbf{Замечание:} хотя битовые строки довольно легковесны, их лучше не применять для пометки кортежей. Весьма соблазнительно было бы использовать строковый литерал, чтобы написать \ops{\{$<<$``temperature''$>>$,50\}}, но в таких случаях всегда используйте атомы. Ранее в этой главе было сказано, что атомы занимают всего 4 или 8 байт, независимо от их длины. Когда вы их используете, нет практически никаких издержек при копировании данных из функции в функцию или при их пересылке другому Erlang узлу на удалённом сервере.
        
        Верно и обратное: не используйте для замены строк атомы из\--за их лёгкости. Строками можно манипулировать (разбивка, регулярные выражения и т.д.) в то время как атомы можно только сравнивать, и больше с ними ничего не сделаешь.
    \end{minipage}
}
\section{Битовые выражения}
Битовые выражения являются для битового синтаксиса тем же, чем списочные выражения для списков: способом сделать код коротким и ясным. В мире Erlang они появились относительно недавно. В предыдущих версиях Erlang они присутствовали, но модуль, который их реализовывал, требовал для работы специальный флаг компиляции. Начиная с ревизии R13B (о которой здесь идёт речь), они стали стандартом и могут быть использованы где угодно, включая оболочку:
\begin{lstlisting}[style=repl]
1> [ X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].    
[2,4]
\end{lstlisting}

Единственное отличие в синтаксисе от обычных списочных выражений это замена символа \ops{$<-$} на \ops{$<=$}, и использование двоичных данных ($<< >>$) вместо списков ([]). Ранее в этой главе мы видели пример, в котором нам было дано двоичное значение, представляющее собой множество пикселов, к которому мы применили сопоставление с образцом, чтобы вычленить RGB значения для каждого пиксела. В принципе, неплохой метод, но с большими структурами станет сложно читать и поддерживать такой код. То же самое можно проделать при помощи однострочного битового выражения, которое выглядит значительно чище:
\begin{lstlisting}[style=repl]
2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
\end{lstlisting}

Замена \ops{$<-$} на \ops{$<=$} позволяет использовать двоичный поток как генератор. Битовое выражение, по сути, преобразовывает двоичные данные в кортежи целых значений. Существует также другой синтаксис битовых выражения, который позволяет совершить обратное преобразование:
\begin{lstlisting}[style=repl]
4> << <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
\end{lstlisting}

Будьте осторожны. Для элементов результирующей двоичной величины необходимо чётко определить размер, в случае если генератор возвратил двоичные данные:
\begin{lstlisting}[style=repl]
5> << <<Bin>> || Bin <- [<<3,7,5,4,7>>] >>.
** exception error: bad argument
6> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>] >>. 
<<3,7,5,4,7>>
\end{lstlisting}

Также существует возможность использовать битовые выражения с двоичным генератором, если соблюдается вышеуказанное правило о предопределённом размере:
\begin{lstlisting}[style=repl]
7> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
<<4,8,6,5,8>>
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
        \textbf{Замечание:} на момент написания этого текста, битовые выражения использовались достаточно редко и были плохо документированы. Поэтому было принято решение не углубляться дальше основ. Чтобы получить более полное представление о битовом синтаксисе в целом, читайте \href{http://user.it.uu.se/~pergu/papers/erlang05.pdf}{документ, описывающий его спецификацию}.
    \end{minipage}
}
\chapter{Модули}
\label{modules}
\section{Что такое модули}
\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{modules.png}
\end{wrapfigure}

Работа с интерактивной оболочкой часто считается жизненно важной частью работы с динамическими языками программирования. В ней удобно тестировать различный код и программы. Чтобы использовать большую часть основных типов данных в Erlang, даже не нужно открывать текстовый редактор или сохранять файлы. Можете отставить клавиатуру в сторону, сказать что на сегодня довольно, и пойти гулять. Но если вы на этом остановитесь, то будете ужасным программистом на Erlang. Чтобы использовать код, его нужно где\--то хранить!

Для этого и существуют модули. Модуль \--- это несколько функций, сгруппированных в единый файл под одним именем. Все функции в Erlang должны определяться в модулях. Вы уже использовали модули, возможно даже не догадываясь об этом. Встроенные функции \ops{hd} и \ops{tl}, которые упоминались в предыдущей главе, на самом деле входят в модуль \ops{erlang}, так же как и все арифметические, логические и булевы операторы. ВФ из модуля \ops{erlang} отличаются от других функций тем, что при использовании Erlang они импортируются автоматически. Вызов любой другой функции, определённой в модуле, должен выглядеть так: \ops{Module:Function(Arguments)}.

Смотрите:
\begin{lstlisting}[style=repl]
1> erlang:element(2, {a,b,c}).
b
2> element(2, {a,b,c}).
b
3> lists:seq(1,4).
[1,2,3,4]
4> seq(1,4).
** exception error: undefined shell command seq/2
\end{lstlisting}

В этом примере функция \ops{seq} из модуля list не была автоматически импортирована, тогда как \ops{element} была. Ошибку ''undefined shell command'' генерирует оболочка, которая ищет и не находит команду оболочки (например, такую как \ops{f()}). Некоторые функции из модуля \ops{erlang} не импортируются автоматически, но их используют не так часто.

Согласно логике, вы должны помещать функции, которые касаются похожих вещей, в один модуль. Общие операции над списками хранятся в модуле \ops{lists}, а функции ввода\--вывода (которые позволяют выводить данные в консоль или файл), сгруппированы в модуле \ops{io}. Единственный модуль, который не подчиняется этой схеме, это вышеупомянутый модуль \ops{erlang}, который содержит математические функции, функции преобразования, мультипроцессинга, изменения настроек виртуальной машины и т.д. У этих функций нет ничего общего, кроме того что все они считаются встроенными. Лучше не создавать модули, похожие на \ops{erlang}, и сконцентрироваться на ясном логическом разделении функциональности.
\section{Объявление модуля}
\begin{wrapfigure}{l}{0.2\linewidth}
    \includegraphics[width=1\linewidth]{declaration.png}
\end{wrapfigure}
Можно объявлять при написании модуля два вида сущностей: функции и атрибуты. Атрибуты это метаданные, которые описывают сам модуль: его имя, функции, которые должны быть видимы снаружи, автора кода и прочее. Эти метаданные весьма полезны, так как подсказывают компилятору, как он должен производить обработку, а также позволяют людям извлекать из скомпилированного кода полезную информацию, не обращаясь к исходному коду.

В Erlang существует большое количество разнообразных атрибутов модулей. Вы и сами можете объявить любые атрибуты на собственный вкус. Но также существуют некоторые предопределённые атрибуты, которые будут появляться в вашем коде чаще других. Все атрибуты модулей записываются в форме \ops{-Name(Attribute).}. Чтобы ваш модуль можно было скомпилировать, необходим лишь один атрибут:

\begin{minipage}{1\linewidth}
    \textbf{-module(Name).}\\ 
    Этот атрибут всегда указывается первым оператором в файле и обозначает имя текущего модуля, где \emph{Name} это ~\ref{atoms}{~атом}. Это имя используется при вызове функций из другого модуля. Вызовы записывают в виде \ops{M:F(A)}, где \emph{M} это имя модуля, \emph{F} это имя функции и \emph{A} её аргументы.
\end{minipage}

Настало время немного попрограммировать! Наш первый модуль будет простым и бесполезным. Откройте текстовый редактор, введите указанную ниже строку, и сохраните под именем \ops{useless.erl}:
\begin{lstlisting}[style=repl]
-module(useless).
\end{lstlisting}

Всего лишь одна эта строка уже является рабочим модулем. Конечно, без функций в нём нет никакого смысла. Сначала давайте решим, какие функции будут экспортироваться из нашего <<бесполезного>>. Для этого нам понадобится ещё один атрибут:

\begin{minipage}{1.0\linewidth}
    \textbf{-export([Function1/Arity, Function2/Arity,\ldots,FunctionN/Arity]).}\\ 
    Он используется для определения функций модуля, которые можно вызывать извне. Атрибут содержит список функций с соответствующей им арностью. Арность функции это целое число, которые соответствует количеству аргументов, которые принимает функция. Это важная информация, поскольку разные функции, определённые в модуле, могут иметь одинаковое имя, только если их арность различается. Поэтому функции \ops{add(X, Y)} и \ops{add(X, Y, Z)} будут считаться различными и записываться в виде \ops{add/2} и \ops{add/3} соответственно.
\end{minipage}

\colorbox{lgray}{
    \begin{minipage}{1\linewidth}
                \textbf{Замечание:} экспортируемые функции представляют собой интерфейс модуля. Важно чтобы интерфейс сообщал о модуле только то, что необходимо для его использования и ничего более. Это позволяет менять скрытые детали вашей реализации, не нарушая работу кода, который может полагаться на ваш модуль.
    \end{minipage}
}

Сначала наш модуль экспортирует полезную функцию под названием <<add>>, которая принимает два аргумента. Атрибут \ops{-export} можно добавить после объявления модуля:
\begin{lstlisting}[style=repl]
-export([add/2]).
\end{lstlisting}

Теперь напишем функцию:
\begin{lstlisting}[style=erlang]
add(A,B) ->
    A + B.
\end{lstlisting}

Синтаксис функции соответствует виду \ops{Name(Args) $->$ Body.}, где \emph{Name} должен быть атомом, а \emph{Body} это одно, либо несколько выражений Erlang, разделённых запятыми. Функция должна заканчиваться точкой. Обратите внимание, что Erlang не использует ключевое слово <<return>>. От <<return>> никакой пользы! Вместо этого автоматически будет возвращён результат выполнения последнего выражения в функции, и вам ничего для этого не нужно будет делать.

Добавьте следующую функцию (конечно же, какое руководство без <<Hello world>>! Хоть даже и в четвёртой главе!), и не забудьте добавить её в атрибут \ops{-export}.
\begin{lstlisting}[style=erlang]
%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() ->
io:format("Hello, world!~n").
\end{lstlisting}

Из этой функции нам станет понятно, что каждый комментарий должен начинаться с символа \ops{\%} и состоять из одной строки (то, что в примере используется \ops{\%\%}, не более чем вопрос стиля). Также функция \ops{hello/0} демонстрирует как в вашем модуле можно вызывать функции из внешних модулей. В данном случае это функция \ops{io:format/1}, которая является стандартной функцией для вывода текста (что объясняется в комментарии).

Добавим ещё одну функцию, которая будет использовать и \ops{add/2}, и \ops{hello/0}:
\begin{lstlisting}[style=erlang]
greet_and_add_two(X) ->
    hello(),
    add(X,2).
\end{lstlisting}
\begin{wrapfigure}[8]{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{imports.png}
\end{wrapfigure}

Не забудьте добавить\ops{greet\_and\_add\_two/1} в список экспортируемых функций. Для вызовов \ops{hello/0} и \ops{add/2} указывать имя модуля не нужно, так как они были объявлены в текущем модуле.

Если бы вы захотели вызвать функцию \ops{io:format/1} так же как \ops{add/2} или любую другую функцию, определённую внутри модуля, то вам нужно было бы добавить в начале файла следующий атрибут: \ops{-import(io, [format/1]).}. После этого можно сделать вызов \ops{format(''Hello, World!\~\strut n'').} напрямую. Общий вид атрибута \ops{-import} подчиняется следующей формуле:
\begin{lstlisting}[style=erlang]
-import(Module, [Function1/Arity,..., FunctionN/Arity]).
\end{lstlisting}

Импорт функции это просто быстрый способ получить к ней доступ. Программистам на Erlang не рекомендуется использовать атрибут \ops{-import}, так как считается, что это уменьшает читаемость кода. К примеру, помимо функции \ops{io:format/2} существует также и функция \ops{io\_lib:format/2}. Чтобы понять, какую из них использовал программист, придётся перейти в начало файла и посмотреть, из какого модуля функция была импортирована. Поэтому использование имени модуля в качестве префикса считается хорошим стилем. Обычно импортируют лишь функции, определённые в модуле lists, так как они используются намного чаще других.

Теперь ваш модуль \ops{useless} должен принять следующий вид:
\begin{lstlisting}[style=erlang]
-module(useless).
-export([add/2, hello/0, greet_and_add_two/1]).
 
add(A,B) ->
A + B.
 
%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() ->
io:format("Hello, world!~n").
 
greet_and_add_two(X) ->
hello(),
add(X,2).
\end{lstlisting}

Мы закончили работать с нашим модулем <<useless>>. Можете сохранить файл под именем \ops{useless.erl}. Имя файла должно состоять из имени модуля, определённого в атрибуте \ops{-module}, и заканчиваться расширением '.erl', которое стандартно используется для файлов с исходным кодом Erlang.

Перед тем как скомпилировать модуль и, наконец\--то, опробовать его в деле, мы увидим как определять и использовать макросы. В Erlang макросы очень похожи на выражения <<\#define>> в языке C, и, главным образом, используются для определения коротких функций и констант. Они представляют собой простые текстовые выражения, которые будут заменены перед компиляцией кода. Макросы полезны для того, чтобы не раскидывать по тексту ваших модулей <<магические>> значения. Макрос определяется как атрибут модуля в виде \ops{-define(MACRO, some\_value).} и его можно использовать внутри модуля как \ops{?MACRO}. Макрос в виде <<функции>> можно записать как \ops{-define(sub(X, Y), X - Y).} и использовать в виде \ops{?sub(23, 47)}. Такой макрос позже будет заменён компилятором на выражение \ops{23 - 47}. Кто\--то использует более сложные макросы, но общий синтаксис не меняется.
\section{Компилируем код}
Чтобы код Erlang мог использоваться виртуальной машиной, его компилируют в байт\--код. Компилятор можно вызывать несколькими способами: из командной строки как \ops{\$ erlc flags file.erl}, из оболочки или в модуле как \ops{compile:file(FileName)}, в оболочке как \ops{c()} и т.д.

Пора скомпилировать наш бесполезный модуль и опробовать его. Откройте оболочку Erlang и введите:
\begin{lstlisting}[style=erlang]
1> cd("/path/to/where/you/saved/the-module/").
"Path Name to the directory you are in"
ok
\end{lstlisting}

Оболочка будет искать по умолчанию файлы в той же директории, из которой она стартовала, а также в стандартной библиотеке. Функция \ops{cd/1} определена только в оболочке Erlang. Она позволяет изменить текущую директорию. Пользователи Windows должны использовать в качестве разделителя директорий прямой слеш (косую черту \ops{\//}). Когда мы поменяли текущую директорию на ту, в которой содержится наш модуль, вводим следующую команду:
\begin{lstlisting}[style=erlang]
2> c(useless).
{ok,useless}
\end{lstlisting}

Если сообщение, которое вы получили, отличается от приведённого выше, то убедитесь что файл назван правильно, что вы находитесь в правильной директории и в вашем модуле нет ошибок. Когда компиляция пройдёт успешно, вы увидите, что в директории помимо \ops{useless.erl} появился ещё один файл \--- \ops{useless.beam}. Это скомпилированный модуль. Попробуем воспользоваться нашими функциями:
\begin{lstlisting}[style=erlang]
3> useless:add(7,2).
9
4> useless:hello().
Hello, world!
ok
5> useless:greet_and_add_two(-3).
Hello, world!
-1
6> useless:not_a_real_function().
** exception error: undefined function useless:not_a_real_function/0
\end{lstlisting}

Функции работают как и было задумано: \ops{add/2} складывает числа, \ops{hello/0} выводит <<Hello, world!>>, а \ops{greet\_and\_add\_two/1} делает и то и другое! Вы, вероятно, задали себе вопрос: а почему функция \ops{hello/0} после вывода текста возвращает атом <<ok>>? Потому что функции и выражения в Erlang \textbf{всегда} должны что\--то возвращать, даже когда в других языках они это делать не обязаны. Поэтому функция \ops{io:format/1} возвращает <<ok>>, чтобы обозначить, что выполнение прошло нормально и ошибки отсутствуют.

В выражении 6 отображена ошибка, которая была сгенерирована из\--за отсутствия функции. Если вы забыли проэкспортировать функцию, то получите сообщение именно такого типа.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1\linewidth}
        \textbf{Замечание:} расширение '.beam', если вам интересно, означает \emph{Bogdan/Björn's Erlang Abstract Machine} (так называется виртуальная машина). Существуют также и другие виртуальные машины для Erlang, но сейчас они не более чем достояние истории, и их не используют. Среди них JAM (Joe's Abstract Machine, вобравшая черты Prolog WAM, и старая BEAM, которая предпринимала попытки компиляции из Erlang в C, и после \--- в нативный код. Измерения показали, что выигрыш от применения этого метода был слишком мал, поэтому от него отказались.
    \end{minipage}
}

Существует много флагов, которые позволяют тоньше контролировать процесс компиляции модуля. Их список можно найти в \href{http://erlang.org/doc/man/compile.html}{документации Erlang}. Вот наиболее востребованные флаги:\\ 

\begin{minipage}{0.9\linewidth}
    \textbf{-debug\_info}\\ 
    Добавляет в модуль отладочную информацию, которая необходима для работы инструментов Erlang, таких как отладчик, утилиты статического анализа и покрытия кода.
\end{minipage}

\begin{minipage}{0.9\linewidth}
    \textbf{-\{outdir,Dir\}}\\ 
    Компилятор Erlang будет по умолчанию создавать ''beam'' файлы в текущей директории. Этот флаг позволяет задать путь к директории, в которой будут сохраняться скомпилированные файлы.
\end{minipage}

\begin{minipage}{0.9\linewidth}
    \textbf{-export\_all}\\ 
    Флаг заставляет игнорировать атрибут модуля \ops{-export}. При этом будут проэкспортированы все функции, которые в нём определены. Главным образом этот флаг полезен при тестировании и разработке нового кода, и его не следует использовать на рабочих системах.
\end{minipage}

\begin{minipage}{0.9\linewidth}
    \textbf{\{d,Macro\} или \{d,Macro,Value\}}\\ 
    Определяет макрос, который можно будет использовать в модуле. \emph{Macro} должен быть атомом. Чаще всего этот флаг используется при юнит\--тестировании, чтобы гарантировать, что тестовые функции будут создаваться и экспортироваться только когда в них есть необходимость. По умолчанию элемент \emph{Value} имеет значение <<true>>, если не указан в списке явно.
\end{minipage}

Чтобы скомпилировать наш модуль \ops{useless} с использованием флагов, нужно выполнить одну из следующих директив:
\begin{lstlisting}[style=erlang]
7> compile:file(useless, [debug_info, export_all]).
{ok,useless}
8> c(useless, [debug_info, export_all]).
{ok,useless}
\end{lstlisting}

Также можно схитрить и определить флаги компиляции при помощи атрибутов прямо в самом модуле. Чтобы получить такой же результат как в выражениях 7 и 8, необходимо добавить в модуль следующую строку: 
\begin{lstlisting}[style=erlang]
-compile([debug_info, export_all]).
\end{lstlisting}

Далее необходимо лишь скомпилировать модуль, и вы получите тот же результат, что и с флагами переданными вручную. А теперь, когда мы можем записывать функции, компилировать их и исполнять, настало время узнать, что же мы сможем со всем этим сделать!\\ 
\colorbox{lgray}
{
    \begin{minipage}{1\linewidth}
        \textbf{Замечание:} модуль также можно скомпилировать в нативный код. Компиляция в нативный код доступна не для каждой платформы и ОС. Для платформ, которые допускают такую компиляцию, можно добиться ускорения программ (по неточным данным приблизительно на 20\%). Для компиляции в нативный код необходимо использовать модуль \ops{hipe}. Компиляция осуществляется при помощи команды: \ops{hipe:c(Module,OptionsList).} Также в оболочке можно использовать команду \ops{c(Module,[\{hipe,o3\}]).} Обратите внимание, что .beam файл, полученный в результате такой компиляции, нельзя переносить между платформами, тогда как обычные файлы можно.
    \end{minipage}
}
\section{Подробнее о модулях}
Прежде чем переходить к написанию функций и кода, польза которых сомнительна, необходимо упомянуть ещё несколько фактов, которые в будущем могут пригодиться.

Первый из них касается метаданных в модулях. Я упомянул в начале главы, что атрибуты модуля \---это метаданные, которые описывают сам модуль. Как мы можем получить доступ к этим метаданным, если у нас нет доступа к исходному коду модуля? В этом нам поможет компилятор. При компиляции он соберёт атрибуты и сохранит их (вместе с другой информацией) в функции \ops{module\_info/0}. Вот так будут выглядеть метаданные модуля \ops{useless}:
\begin{lstlisting}[style=erlang]
9> useless:module_info().
[{exports,[{add,2},
            {hello,0},
            {greet_and_add_two,1},
            {module_info,0},
    {module_info,1}]},
    {imports,[]},
    {attributes,[{vsn,[174839656007867314473085021121413256129]}]},
    {compile,[{options,[]},
            {version,"4.6.2"},
            {time,{2009,9,9,22,15,50}},
{source,"/home/ferd/learn-you-some-erlang/useless.erl"}]}]
10> useless:module_info(attributes).
[{vsn,[174839656007867314473085021121413256129]}]
\end{lstlisting}

Также в вышеприведённом тексте есть упоминание дополнительной функции \ops{module\_info/1}, которая позволит получить каждый элемент метаданных по отдельности. В метаданных содержатся экспортируемые функции, импортируемые функции (в данном случае ни одной), атрибуты (в них можно хранить метаданные, которые определены вами), информация о компиляции и ключи компиляции. Если бы вы решили добавить в модуль атрибут \ops{-author(``An Erlang Champ'').}, он оказался бы в том же разделе, где и \ops{vsn}. Когда дело доходит до рабочей системы, для атрибутов модулей маловато применений, но они могут быть полезны для реализации маленьких хитростей: я использую их в \href{http://learnyousomeerlang.com/static/erlang/tester.erl}{тестовом скрипте}, чтобы описывать функции для которых юнит\--тесты оставляют желать лучшего. Скрипт сканирует атрибуты модуля, находит функции, снабжённые комментариями, и выдаёт о них предупреждения.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1\linewidth}
        \textbf{Замечание:} \ops{vsn} это уникальное значение, которое генерируется автоматически и отличается для каждой версии вашего кода, исключая комментарии. Это значение используется при горячей загрузке кода (обновление приложения во время исполнения, без необходимости его остановки), а также некоторыми инструментами, которые связаны с управлением релизами. Если хотите, можете сами указать значение для \ops{vsn}: просто добавьте в модуль атрибут \ops{-vsn(VersionNumber)}.
    \end{minipage}
}

\begin{wrapfigure}{r}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{circular-dependencies.png}
\end{wrapfigure}
Ещё один момент, на который стоит обратить внимание при проектировании модулей: избегайте циклических зависимостей! Модуль \emph{A} не должен вызывать модуль \emph{B}, который в свою очередь вызывает модуль \emph{A}. Такие зависимости приводят к усложнению поддержки кода. Кому хочется проснуться посреди ночи от того, что маньяк\--разработчик пытается выдавить вам глаза из\--за чудовищного кода, который вы написали.

По той же причине (поддержка кода и забота о вашим зрении), обычно считается хорошим тоном размещение рядом функций близких по назначению. В качестве примера можно привести функции запуска и остановки приложения, или создания и удаления записи в некоторой базе данных.

Ну что, довольно морализаторства. Готовы узнать ещё немного об Erlang?
\chapter{Синтаксис функций}
\label{syntax_in_functions}
\section{Сопоставление с образцом}
\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{snail.png}
\end{wrapfigure}
Теперь, когда у нас есть возможность сохранять и компилировать наш код, мы можем начать писать более сложные функции. Те, что мы написали раньше, были чрезвычайно просты и восторгаться в них было нечем. Перейдём к более интересным вещам. Первая функция, которую мы напишем, будет выдавать различные приветствия в зависимости от переданного ей пола. В большинстве языков нужно было бы написать что\--то близкое к этому:
\begin{lstlisting}[style=erlang]
function greet(Gender,Name)
    if Gender == male then
        print("Hello, Mr. %s!", Name)
    else if Gender == female then
        print("Hello, Mrs. %s!", Name)
    else
        print("Hello, %s!", Name)
end
\end{lstlisting}

С использованием сопоставления с образцом, Erlang позволяет избавиться от кучи шаблонного кода. В Erlang подобная функция будет выглядеть так:
\begin{lstlisting}[style=erlang]
greet(male, Name) ->
    io:format("Hello, Mr. ~s!", [Name]);
greet(female, Name) ->
    io:format("Hello, Mrs. ~s!", [Name]);
greet(_, Name) ->
    io:format("Hello, ~s!", [Name]).
\end{lstlisting}

Признаю, что функция вывода в Erlang выглядит намного уродливее, чем в других языках, но смысл не в этом. Главное отличие в том, что при использовании сопоставления с образцом, мы убили сразу двух зайцев: определили, какие части функции будут использованы, и связали значения с переменными. Нам не нужно сначала связывать значения, а потом их сравнивать! Поэтому вместо:
\begin{lstlisting}[style=erlang]
function(Args)
    if X then
        Expression
    else if Y then
        Expression
    else
        Expression
\end{lstlisting}
Мы напишем:
\begin{lstlisting}[style=erlang]
function(X) ->
    Expression;
function(Y) ->
    Expression;
function(_) ->
    Expression.
\end{lstlisting}

и придём к тем же результатам, используя более декларативный стиль. Каждое объявление \ops{function} называется \emph{функциональным выражением}. Функциональные выражения должны разделяться символом точки с запятой (\ops{;}) и вместе они формируют \emph{объявление функции}. Объявление функции считается одной большой конструкцией, поэтому заключительное функциональное выражение завершается точкой. Этот способ использования элементов для определения потока задач (workflow), может показаться немного <<странным>>, но вы к нему привыкнете. Ну или хотя бы надейтесь на то, что это случится, потому что иного пути не существует!\\
\colorbox{lgray}
{
    \begin{minipage}{1\linewidth}
        \textbf{Замечание:} форматирование при помощи \ops{io:format} осуществляется при помощи токенов, которые определяют замены в строке. Для обозначения токенов используется символ тильды (\ops{\strut\mytilde}). Есть встроенные токены, например\ops{\mytilde n}. Этот токен будет преобразован в перевод строки. Большинство других токенов обозначают способ форматирования данных. Например, вызов функции \ops{io:format(``\mytilde s!\mytilde n'',[``Hello'']).} заключает в себе токен \ops{\mytilde n}, и токен \ops{\mytilde s}, который в качестве аргументов принимает строки и битовые строки. После применения форматирования, строка примет вид \ops{``Hello!\\n''}. Ещё одним широко используемым токеном является \ops{\mytilde p}. Он печатает содержимое переменной Erlang, учитывая форматирование (с добавлением отступов и всего прочего).\\ 
        Мы ознакомимся с подробностями применения функции \ops{io:format} в последующих главах, когда будем углублённо работать с вводом/выводом. Но сейчас можете попробовать исполнить следующие вызовы функций: \ops{io:format(''\mytilde s\mytilde n'',[$<<$''Hello''$>>$])}, \ops{io:format''\mytilde p\mytilde n'', [$<<$''Hello''$>>$])}, \ops{io:format(''\mytilde\mytilde\mytilde n'')}, \ops{io:format(''\mytilde f\mytilde n'', [4.0])}, \ops{io:format(''\mytilde 30f\mytilde n'', [4.0])}. Это лишь малая часть возможных операций. Команды немного похожи на \ops{printf} из другого языка. Если не можете дотерпеть до главы, в которой описывается ввод/вывод, то почитайте \href{http://erlang.org/doc/man/io.html\#format-3}{документацию онлайн}.
    \end{minipage}
}

В функциях сопоставление с образцом может принимать ещё более сложные и мощные формы. Как вы, может быть, помните, несколько глав назад мы применяли сопоставление с образцом, чтобы получать головную и хвостовую части списков. Давайте попробуем это сделать снова! Создайте новый модуль и назовите его \ops{functions}. В нём мы напишем несколько функций, которые позволят нам исследовать пути использования сопоставления с образцом:
\begin{lstlisting}[style=erlang]
-module(functions).
-compile(export_all). %% replace with -export() later, for God's sake!
\end{lstlisting}

Первой нашей функцией станет \ops{head/1}, которая будет вести себя точно так же как \ops{erlang:hd/1}: принимать список в качестве аргумента и возвращать его первый элемент. Мы будем это делать при помощи оператора cons (\ops{\strut|}):
\begin{lstlisting}[style=erlang]
head([H|_]) -> H.
\end{lstlisting}

Если вы введёте в оболочке \ops{functions:head([1,2,3,4]).} (после того как скомпилируете модуль), то вам будет возвращено значение '1'. Чтобы получить второй элемент, следовательно, вам нужно создать функцию: 
\begin{lstlisting}[style=erlang]
second([_,X|_]) -> X.
\end{lstlisting}

Список будет разобран Erlang при помощи сопоставления с образцом. Поробуйте выполнить эту операцию в оболочке!
\begin{lstlisting}[style=erlang]
1> c(functions).
{ok, functions}
2> functions:head([1,2,3,4]).
1
3> functions:second([1,2,3,4]).
2
\end{lstlisting}

Можно повторять этот процесс для списков сколько угодно, но для тысячи значений это было бы непрактично. Для того чтобы это исправить, мы будем писать рекурсивные функции, которые разберём чуть позже. А сейчас давайте сосредоточимся на сопоставлении с образцом. Концепция свободной и связанной переменной, которую мы обсуждали в главе ~\ref{starting_out_for_real} также справедлива и для функций. Мы можем сравнивать и выяснять, одинаковы ли два параметра, которые переданы в функцию. Для этого мы создадим функцию \ops{same/2}, которая принимает два аргумента и сообщает, совпадают ли они друг с другом:
\begin{lstlisting}[style=erlang]
same(X,X) ->
true;
same(_,_) ->
false.
\end{lstlisting}

Вот так всё просто. Прежде чем объяснять как работают функции, мы ещё раз повторим концепцию связанной и свободной переменной, на всякий случай:
\begin{wrapfigure}{i}{0.7\linewidth}
    \includegraphics[width=1\linewidth]{un-bound.png}
\end{wrapfigure}
На этой картинке жених опечален, потому что в Erlang переменные никогда не могут менять значение: конец свободе! А если серьёзно, то свободными называются переменые, у которых ничего нет (как у нашего маленького бомжика справа). Процесс связывания переменной заключается в простом присоединении значения к свободной переменной. Если вы захотите присвоить значение связанной переменной, Erlang сгенерирует ошибку. Но ошибки не будет, если новое значение совпадает со старым. Представим, что парень слева женится на девушке, у которой есть сестра\--близнец. Если рядом появится сестра, жених не отличит её от невесты, и никак не отреагирует. Если же появится посторонняя женщина, жених будет недоволен. Если вам неясна эта концепция, можете вернуться к разделу о \ref{invariable_variables}{~Неизменных переменных}.

Вернёмся к нашему коду. Когда вы вызовете функцию \ops{same(a,a)}, то первая переменная \emph{X} считается свободной и автоматически принимает значение \ops{a}. Далее Erlang переходит ко второму аргументу, видит что переменная \emph{X} уже связана. После этого он сравнивает её со значением \ops{a}, которое было передано в качестве второго аргумента, и определяет, совпадают ли они друг с другом. Операция сопоставления с образцом завершается успешно и функция возвращает \ops{true}. Если два значения различаются, то сравнение завершится неудачей, и управление перейдёт к второму функциональному выражению, которое не проверяет аргументы (когда выбирать не из чего, нечего перебирать!), а просто возвращает false. Заметьте, что эта функция может фактически принимать абсолютно любые аргументы! Она работает не только со списками или с одиночными переменными, а с любыми типами данных. Рассмотрим пример посложнее: функцию, которая печатает дату, но лишь тогда, когда она правильно отформатирована:
\begin{lstlisting}[style=erlang]
valid_time({Date = {Y,M,D}, Time = {H,Min,S}}) ->
    io:format("The Date tuple (~p) says today is: ~p/~p/~p,~n",[Date,Y,M,D]),
    io:format("The time tuple (~p) indicates: ~p:~p:~p.~n", [Time,H,Min,S]);
valid_time(_) ->
    io:format("Stop feeding me wrong data!~n").
\end{lstlisting}

Есть также возможность использовать оператор \ops{\strut=}, который позволяет сопоставлять не только содержимое кортежа (\ops{\{Y,M,D\}}), но и сам кортеж в целом (\emph{Date}). Функцию можно протестировать следующим образом:
\begin{lstlisting}[style=erlang]
4> c(functions).
{ok, functions}
5> functions:valid_time({{2011,09,06},{09,04,43}}).
The Date tuple ({2011,9,6}) says today is: 2011/9/6,
The time tuple ({9,4,43}) indicates: 9:4:43.
ok
6> functions:valid_time({{2011,09,06},{09,04}}).
Stop feeding me wrong data!
ok
\end{lstlisting}

Правда есть одна проблема! Эта функция будет принимать в качестве входящих данных что угодно, даже текст или атомы. Достаточно лишь, чтобы кортежи имели вид \ops{\{\{A,B,C\}, \{D,E,F\}\}}. Вот мы и пришли к одному из ограничений сопоставления с образцом: с его помощью можно указать либо очень точные значения, например известное число или атом, либо абстрактные значения, такие как голова|хвост списка, кортеж из \emph{N} элементов, или что угодно другое (\ops{\strut\_} и свободные переменные), и т.д. Чтобы решить эту проблему мы используем охранные выражения, стражи (guards). 
\section{Стража! Стража!}
    Стражи \--- это дополнительные выражения, которые можно добавлять в заголовки функций, чтобы сделать сопоставление с образцом более выразительным. Как уже упоминалось выше, в сопоставлении с образцом есть ограничения, так как с его помощью нельзя сопоставлять, к примеру, диапазон значений, или  определённые типы данных. Мы не можем выразить концепцию счёта: слишком ли низок этот двенадцатилетний баскетболист, чтобы играть с профессионалами? Слишком ли велика эта дистанция, чтобы пройти её на руках? Ты слишком стар, или слишком молод, чтобы водить машину? На такие вопросы не ответишь, применяя лишь простое сопоставление с образцом. Конечно, можно представить вопрос про вождение в таком виде:
\begin{lstlisting}[style=erlang]
old_enough(0) -> false;
old_enough(1) -> false;
old_enough(2) -> false;
...
old_enough(14) -> false;
old_enough(15) -> false;
old_enough(_) -> true.
\end{lstlisting}

Но это уж слишком громоздко. Если хотите, можете так делать, но будьте готовы работать над своим кодом в гордом одиночестве. Если всё же хотите со временем обзавестись друзьями, создайте новый модуль \ops{guards}, в котором мы реализуем <<правильное>> решение для вопроса о вождении:
\begin{lstlisting}[style=erlang]
old_enough(X) when X >= 16 -> true;
old_enough(_) -> false.
\end{lstlisting}

Вот и всё! Как видите, такая запись намного короче и понятнее. Основное правило для охранных выражений: чтобы выражение сработало, оно должно возвращать \ops{true}. Если страж возвращает \ops{false}, или бросает исключение, то оно не срабатывает. Предположим, что мы хотим запретить садиться за руль людям старше 104 лет. Водить можно только в возрасте от 16 до 104 лет. Как же нам выполнить это условие? Давайте просто добавим второе охранное выражение:
\begin{lstlisting}[style=erlang]
right_age(X) when X >= 16, X =< 104 ->
    true;
right_age(_) ->
    false.
\end{lstlisting}

Запятая (\ops{\strut,}) по выполняемой роли похожа на оператор\ops{andalso}, а точка с запятой (\ops{;}) ведёт себя приблизительно как\ops{orelse} (эти операторы описаны в разделе \ref{boolandcompare}{~Булева алгебра и операторы сравнения}). Чтобы всё выражение успешно выполнилось, необходимо чтобы было удовлетворено условие в обоих охранных выражениях. Также можно поменять условия в функции на противоположные:
\begin{lstlisting}[style=erlang]
wrong_age(X) when X < 16; X > 104 ->
    true;
wrong_age(_) ->
    false.
\end{lstlisting}
\begin{wrapfigure}{l}{0.2\linewidth}
    \includegraphics[width=1\linewidth]{guard.png}
\end{wrapfigure}

И с этим выражением мы всё равно получим правильные результаты. Если хотите, можете протестировать (вы всегда должны всё проверять!). В охранных выражениях точка с запятой (\ops{;}) ведёт себя как оператор\ops{orelse}: если первый страж не исполняется, то исполнение переходит ко второму, потом к следующему, до тех пор пока хотя бы один страж возвратит истину или все стражи возвратят ложь.

Помимо функций сравнения и булевых операторов, можно использовать и другие функции, включая математические операции (\ops{A*B\//C >= 0}) и функции определения типа, такие как \ops{is\_integer/1}, \ops{is\_atom/1}, и т.д. (Мы вернёмся к ним в следующей главе). Одним из недостатков охранных выражений является то, что они не принимают функции определённые пользователем из\--за возможных побочных эффектов. Erlang не чистый функциональный язык программирования (коим является, к примеру, \href{http://learnyouahaskell.com}{Haskell}) потому что во многом полагается на побочные эффекты: можно выполнять операции ввода\--вывода, пересылать между акторами сообщения, выбрасывать исключения когда угодно и где угодно. Не существует простого способа определить, что функция, которая используется в охранном выражении, печатает текст. А может быть не печатает. А может быть она перехватывает важные сообщения об ошибках при тестировании в нескольких функциональных выражениях. Поэтому Erlang просто вам не доверяет (и, скорее всего, правильно делает!)

    После всего сказанного, у вас должно было появиться понимание базового синтаксиса охранных выражений, достаточное для того чтобы не теряться при встрече с ними.\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
        \textbf{Замечание:} я сравнивал символы \ops{,} и \ops{;} в охранных выражениях с операторами \ops{andalso} и \ops{orelse}. По правде говоря, они не совсем эквивалентны. Первые будут захватывать возникающие исключения, а вторые не будут. Это означает, что если в первой части охранного выражения \ops{X $>=$ N; N $>=$ 0} будет сгенерирована ошибка, то вторая часть всё же будет исполнена, и выражение может сработать. Если ошибка была выброшена в первой части выражения \ops{X $>=$ N orelse N $>=$ 0}, то вторая часть будет пропущена, и всё охранное выражение не сработает.\\ 
        Однако (всегда есть какое\--нибудь <<однако>>) только операторы \ops{andalso} и \ops{orelse} могут помещаться в охранное выражение. Это означает, что \ops{(A orelse B) andalso C} это валидное выражение, а \ops{(A; B), C} \--- нет. Нужно учитывать их различное назначение и использовать в сочетании друг с другом.
    \end{minipage}
}

\section{Что ещё за <<If>>?!}
\ops{If}\--ы ведут себя подобно охранным выражениям и имеют тот же синтаксис, но используются за пределами заголовка функции. Они даже называются \emph{Охранными шаблонами}. \ops{if}\--ы в Erlang отличаются от \ops{if}\--ов в большинстве других языков. По сравнению с ними, это странные создания, которых принимали бы охотнее, называйся они иначе. Вступая в страну Erlang, оставьте всё что вы знаете об \ops{if} на пороге. Займите своё место \--- мы отправляемся в путешествие.

Чтобы понять как похожи выражения \ops{if} на охранные выражения, взгляните на следующие примеры:
\begin{lstlisting}[style=erlang]
-module(what_the_if).
-export([heh_fine/0]).
 
heh_fine() ->
    if 1 =:= 1 ->
        works
    end,
    if 1 =:= 2; 1 =:= 1 ->
        works
    end,
    if 1 =:= 2, 1 =:= 1 ->
        fails
    end.
\end{lstlisting}
Сохраним этот код в файл \ops{what\_the\_if.erl}, и попробуем его исполнить:
\begin{lstlisting}[style=repl]
1> c(what_the_if).
./what_the_if.erl:12: Warning: no clause will ever match
./what_the_if.erl:12: Warning: the guard for this clause evaluates to 'false'
{ok,what_the_if}
2> what_the_if:heh_fine().
** exception error: no true branch found when evaluating an if expression
    in function  what_the_if:heh_fine/0
\end{lstlisting}
Ой! Компилятор нас предупреждает, что условие if в строке 12 (\ops{1 =:= 2, 1 =:= 1}) никогда не будет использовано, так как его единственное охранное выражение всегда возвращает \ops{false}. Помните, в Erlang всё должно что\--то возвращать, и \ops{if}\-- выражения не являются исключением из этого правила. 
\begin{figure}[h!]
    \includegraphics[width=0.3\linewidth]{labyrinth.png}
\end{figure}
Таким образом, когда Erlang не может найти случай, в котором страж успешно выполнится, будет сгенерирована ошибка: возвращать в этом случае нечего. Поэтому мы должны добавить ветвь, которая будет успешно исполняться не смотря ни на что. В большинстве языков это бы называлось 'else'. В Erlang мы используем слово 'true' (это объясняет, почему VM сгенерировала сообщение <<no true branch found>>)
\begin{lstlisting}[style=erlang]
oh_god(N) ->
    if N =:= 2 -> might_succeed;
        true -> always_does  %% this is Erlang's if's 'else!'
    end.
\end{lstlisting}

Если мы теперь протестируем эту новую функцию (старая будет продолжать плеваться предупреждениями. Можно их игнорировать или оставить как напоминание о том, как делать нельзя):
\begin{lstlisting}[style=erlang]
3> c(what_the_if).
./what_the_if.erl:12: Warning: no clause will ever match
./what_the_if.erl:12: Warning: the guard for this clause evaluates to 'false'
{ok,what_the_if}
4> what_the_if:oh_god(2).
might_succeed
5> what_the_if:oh_god(3).
always_does
\end{lstlisting}

Вот ещё одна функция, которая показывает как использовать несколько стражей в \ops{if}\--выражении. Эта же функция также демонстрирует, что любое выражение должно что\--нибудь возвращать: к переменной \emph{Talk} привязывается результат выражения \ops{if} и затем конкатенируется в строку, которая входит в состав кортежа. Читая код, легко увидеть как отсутствие ветки \ops{true} могло бы всё испортить, если учитывать, что в Erlang не существует такого понятия как null\--значение (как nil в lisp, NULL в C, None в Python и т.д.):
\begin{lstlisting}[style=erlang]
%% note, this one would be better as a pattern match in function heads!
%% I'm doing it this way for the sake of the example.
help_me(Animal) ->
    Talk = if Animal == cat  -> "meow";
            Animal == beef -> "mooo";
            Animal == dog  -> "bark";
            Animal == tree -> "bark";
            true -> "fgdadfgna"
        end,
    {Animal, "says " ++ Talk ++ "!"}.
\end{lstlisting}
А теперь попробуем исполнить:
\begin{lstlisting}[style=erlang]
6> c(what_the_if).
./what_the_if.erl:12: Warning: no clause will ever match
./what_the_if.erl:12: Warning: the guard for this clause evaluates to 'false'
{ok,what_the_if}
7> what_the_if:help_me(dog).
{dog,"says bark!"}
8> what_the_if:help_me("it hurts!").
{"it hurts!","says fgdadfgna!"}
\end{lstlisting}
Как и множество программистов на Erlang, вы, должно быть, недоумеваете \--- почему 'true' взяло верх над 'else' в качестве атома для управления потоком исполнения? В конце концов, 'else' более привычен. Richard O'Keefe дал в почтовой рассылке Erlang следующий ответ на этот вопрос. Я привожу его здесь без купюр, потому что сам не смог бы сформулировать лучше:\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
    Может быть 'else' и привычнее, но это не означает, что 'else' это хорошо. Я понимаю, что при помощи выражения '; true ->' очень легко получить в Erlang 'else', но результаты двух десятков лет наблюдений за психологией программирования показывают, что ни к чему хорошему это не приведёт. Я начал заменять:
\end{minipage}
}
\begin{lstlisting}[style=erlang]
if X > Y -> a()
    ; true  -> b()
if X > Y -> a()
    ; X < Y -> b()
    ; true  -> c()
end
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
на
    \end{minipage}
}
\begin{lstlisting}[style=erlang]     
if X > Y  -> a()
    ; X =< Y -> b()
end

if X > Y -> a()
    ; X < Y -> b()
    ; X == Y -> C()
end
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
это немного раздражает, когда я \textbf{пишу} код, но чрезвычайно помогает, когда я его \textbf{читаю}.
    \end{minipage}
}

Лучше всего <<избегать>> и 'else' и 'true': \ops{if}\--ы обычно легче читать, когда явно покрываются все логические исходы, без использования выражения, которое <<ловит всё подряд>>.

Как упоминалось ранее, в охранных выражениях можно использовать ограниченный набор функций (мы ещё с ними встретимся в \ref{types_or_lack_thereof}{Типы (или их отсутствие)}. Настало время явить подлинную мощь условных операторов Erlang. Я представляю вам выражение \ops{case}!\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} весь ужас, отражённый в названиях функций файла \ops{what\_the\_if.erl}, относится к языковой конструкции \ops{if}, если рассматривать её с точки зрения \ops{if} любого другого языка. В контексте Erlang эта конструкция оказывается абсолютно логичной, просто её имя сбивает с толку.
    \end{minipage}
}
\section{В случае\ldots если}

Если считать, что выражения \ops{if} похожи на стражей, то \ops{case \ldots of} похоже на заголовок функции в целом. Для каждого аргумента можно применять сложные выражения сопоставления с образцом и, вдобавок, использовать стражи!

Так как вы уже неплохо знакомы с синтаксисом, нам не понадобится много примеров. На этот раз мы напишем функцию дополнения (append) для множеств (sets) (набор уникальных значений), который мы представим как неупорядоченный список. В смысле эффективности это, пожалуй, наихудшая возможная реализация наборов, но сейчас мы заботимся не об эффективности, а о синтаксисе:
\begin{lstlisting}[style=erlang]
insert(X,[]) ->
    [X];
insert(X,Set) ->
    case lists:member(X,Set) of
        true  -> Set;
        false -> [X|Set]
    end.
\end{lstlisting}
Если мы передаём в функцию пустое множество (список) и терм \emph{X}, она возвращает нам список, который содержит лишь \emph{X}. Иначе, функция \ops{lists:member/2} проверяет, не является ли элемент частью списка, и возвращает true, если является и false, если нет. В случае, когда в нашем множестве уже присутствует элемент \emph{X}, нам не нужно изменять список. Если элемента в списке нет, то мы добавляем \emph{X} первым элементом списка.

В нашем примере, сопоставление с образцом было очень простым. Оно может усложняться (можете сравнить ваш код с \href{http://learnyousomeerlang.com/static/erlang/cases.erl}{моим}):
\begin{lstlisting}[style=erlang]
beach(Temperature) ->
    case Temperature of
        {celsius, N} when N >= 20, N =< 45 ->
            'favorable';
        {kelvin, N} when N >= 293, N =< 318 ->
            'scientifically favorable';
        {fahrenheit, N} when N >= 68, N =< 113 ->
            'favorable in the US';
        _ ->
            'avoid beach'
    end.
\end{lstlisting}
Здесь представлен ответ на вопрос <<не сходить ли  на пляж?>> для трёх температурных систем: Цельсия, Кельвина и Фаренгейта. Сопоставление с образцом комбинируется со стражами и, в конце концов, возвращает ответ, который удовлетворяет всем вариантам использования. Как было указано ранее,  выражения \ops{case\ldots of} это практически то же самое, что и группа заголовков функций со стражами. Мы даже могли бы записать наш код в следующем виде:
\begin{lstlisting}[style=erlang]
beachf({celsius, N}) when N >= 20, N =< 45 ->
    'favorable';
...
beachf(_) ->
    'avoid beach'.
\end{lstlisting}

Это вызывает вопрос: когда нужно использовать \ops{if}, а когда \ops{case \ldots of} или функции для записи условных выражений?
\section{Что же использовать?}
\begin{figure}[h!]
    \includegraphics[width=0.3\linewidth]{coppertone.png}
\end{figure}
На вопрос <<Что же использовать?>>, \--- ответить довольно сложно. Между вызовами функций и конструкцией \ops{case \ldots of} разница очень невелика. На самом деле на низком уровне они реализованы одинаково, поэтому с точки зрения производительности они ничем не отличаются. Различия появляются, когда обрабатывается более чем один аргумент: \ops{function(A,B) -> \ldots end.} может использовать стражи, чтобы сопоставлять  с образцом A и B, тогда как case выражение было бы необходимо сформулировать приблизительно следующим образом:
\begin{lstlisting}[style=erlang]
case {A,B} of
    Pattern Guards -> ...
end.
\end{lstlisting}

Такая форма редко встречается и наверняка застанет читателя врасплох. В похожих ситуациях правильнее было бы использовать вызов функции. С другой стороны, функция \ops{insert/2}, которую мы записали ранее, определённо выглядит яснее в своём текущем виде, без прямого вызова функции, которая проходит по веткам \ops{true} или \ops{false}.

Следующий вопрос \--- зачем тогда вообще использовать \ops{if}, если \ops{case} и функции достаточно гибки, чтобы реализовать \ops{if} посредством стражей? За \ops{if} стоит простая логика: эта конструкция была добавлена в язык, чтобы иметь возможность использовать стражи, не описывая сопоставления с образцом, когда в них нет необходимости.

Конечно же, всё это относится больше к индивидуальным предпочтениям. Определённого ответа на этот вопрос не существует. Эта тема до сих пор время от времени обсуждается сообществом Erlang. Если ваш код прост для понимания, никто вас бить не будет, какой бы путь вы не избрали. Как однажды сказал Ward Cunningham: <<Код можно считать ясным, когда вы смотрите на подпрограмму, и она выглядит приблизительно так, как вы и ожидали.>>
\chapter{Типы (или их отсутствие)}
\label{types_or_lack_thereof}
\section{Сильнейшая типизация}
Как вы, вероятно, заметили во время ввода примеров из \ref{starting_out_for_real}, а потом модулей и функций из \ref{modules} и \ref{syntax_in_functions}, нам не нужно было вводить тип переменной или тип функции. При сопоставлении с образцом нашему коду не нужно было знать, с чем производится сопоставление. Кортеж \ops{\{X,Y\}} можно сопоставить с \ops{\{atom, 123\}} с тем же успехом, что и с \ops{\{``A string'', <<``binary stuff!''>>\}}, \ops{\{2.0, [``strings'', ``and'', atoms]\}} или вообще с чем угодно.

Когда это не срабатывало, просто генерировалась ошибка, но так случалось лишь во время исполнения кода. Происходит это потому, что Erlang \--- язык с \emph{динамической типизацией}. Каждая ошибка ловится во время исполнения, и если всё может закончиться аварией, компилятор не всегда будет истошно вопить, как это было в примере \ops{``llama + 5''} из главы \ref{starting_out_for_real}.

\begin{figure}[h!]
    \includegraphics[width=0.4\textwidth]{ham.png}
\end{figure} 
Одно из классических мест трения между сторонниками статической и динамической типизации связано с безопасностью програмного обеспечения. Часто насаждается идея, что хорошая статическая система типов, за исполнением которой с усердием следят компиляторы, будет ловить большинство ошибок ещё до того как код будет исполнен. Поэтому языки со статической типизацией считаются более надёжными, чем их динамические собратья. Хотя для многих динамических языков это действительно так, но к Erlang это относится не в полной мере, и его послужной список это подтверждает. Лучшим примером служит степень готовности к обслуживанию (availability) \emph{девять девяток} (99.9999999\%), которая обеспечивается на свитчах \href{http://www.erlang.se/publications/Ulf_Wiger.pdf}{Ericsson AXD 301 ATM}. Количество строк Erlang\--кода для этих устройств \--- свыше 1 миллиона. Обратите внимание, что это не показатель того, что ни одна из компонент системы, написанной на Erlang, не давала сбой. Это означает, что свитч как единая система был готов к работе 99.9999999\% времени, включая запланированные перерывы. Отчасти это вызвано тем, что Erlang построен на идее, что сбой в одной из компонент не должен влиять на всю систему. Учитываются ошибки, которые делает программист, сбои оборудования или сети. Язык включает возможности, которые позволяют распределять программы на различные узлы, обрабатывать непредвиденные ошибки и \emph{никогда} не останавливаться.

Короче говоря, в то время как большинство языков и систем типов стараются избавить программы от ошибок, Erlang использует стратегию, согласно которой считается, что ошибки в любом случае будут появляться, и старается эти случаи предотвратить. Динамическая система типов в Erlang не является преградой для надёжности и безопасности программ. Звучит это всё как речи проповедника, но в последующих главах вы увидите как это происходит.\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} динамическая типизация была избрана исторически по простой причине. Люди, которые реализовывали Erlang, в большинстве своём имели опыт программирования на языках с динамической типизацией, и поэтому самым естественным выбором для них было сделать Erlang динамическим.
    \end{minipage}
}

Кроме того, Erlang \--- язык с сильной типизацией. Языки со слабой типизацией производят неявные преобразования типов между термами. Если бы Erlang был языком со слабой типизацией, то мы, вероятно, могли бы исполнить операцию \ops{6 = 5 + ``1''}, тогда как в действительности будет выброшено исключение, которое сообщает о неверных аргументах:
\begin{lstlisting}[style=erlang]
1> 6 + "1".
** exception error: bad argument in an arithmetic expression
    in operator  +/2
        called as 6 + "1"
\end{lstlisting}

Конечно же, есть моменты, когда вам бы хотелось преобразовать один вид данных в другой. Например, привести обычный строковый тип к битовым строкам на время хранения, или целое привести к числу с плавающей запятой. Стандартная библиотека Erlang предоставляет для этого множество функций.
\section{Преобразование типов}
Как и многие языки, Erlang меняет тип терма путём приведения его к другому типу. Это происходит с применением встроенных функций, поскольку многие преобразования невозможно реализовать на чистом Erlang. Каждая такая функция принимает форму <тип>\_to\_<тип> и находится в модуле \ops{erlang}. Вот некоторые из них:
\begin{lstlisting}[style=erlang]
1> erlang:list_to_integer("54").
54
2> erlang:integer_to_list(54).
"54"
3> erlang:list_to_integer("54.32").
** exception error: bad argument
    in function  list_to_integer/1
        called as list_to_integer("54.32")
4> erlang:list_to_float("54.32").
54.32
5> erlang:atom_to_list(true).
"true"
6> erlang:list_to_bitstring("hi there").
<<"hi there">>
7> erlang:bitstring_to_list(<<"hi there">>).
"hi there"
\end{lstlisting}

И так далее. Здесь мы натыкаемся на особенность языка: так как используется схема <тип>\_to\_<тип>, то при добавлении нового типа в язык, приходится добавлять множество встроенных функций! Вот их полный список:
\ops{atom\_to\_binary/2, atom\_to\_list/1, binary\_to\_atom/2}\\
\ops{binary\_to\_existing\_atom/2, binary\_to\_list/1,}\\
\ops{bitstring\_to\_list/1, binary\_to\_term/1, float\_to\_list/1,}\\
\ops{fun\_to\_list/1, integer\_to\_list/1, integer\_to\_list/2,}\\
\ops{iolist\_to\_binary/1, iolist\_to\_atom/1, list\_to\_atom/1,}\\
\ops{list\_to\_binary/1, list\_to\_bitstring/1,}\\
\ops{list\_to\_existing\_atom/1, list\_to\_float/1, list\_to\_integer/2,}\\
\ops{list\_to\_pid/1, list\_to\_tuple/1, pid\_to\_list/1,}\\
\ops{port\_to\_list/1, ref\_to\_list/1, term\_to\_binary/1,}\\
\ops{term\_to\_binary/2 и tuple\_to\_list/1.}

Многовато функций. Большинство из них, если не все, мы увидим в этой книге. Впрочем, все они нам вряд ли понадобятся.
\section{Охранять тип данных}
Базовые типы Erlang просто заметить: у кортежей есть фигурные скобки, у списков \--- квадратные, строки заключены в двойные кавычки и т.д. Поэтому определённый тип данных можно использовать в сопоставлении с образцом: функция \ops{head/1}, которая принимает в качестве аргумента список, может принимать списки потому, что для других типов не сработало бы сопоставление (\ops{[H|\_]}).
\begin{figure}[h!]
    \includegraphics[width=0.3\textwidth]{my-name-is.png}
\end{figure} 

Тем не менее, у нас уже возникали проблемы с числовыми значениями, для которых мы не могли задавать диапазоны. Для решения этой проблемы мы использовали стражи в функциях, которые были связаны с температурой, водительским возрастом и т.д. Перед нами встаёт ещё одно препятствие. Как нам записать страж, который применил бы сопоставление с образцом к данным лишь одного определённого типа, такого как числа, атомы или битовые строки?

Для решения этой задачи существуют функции. Они принимают один аргумент и возвращают истину, если тип верный и ложь в противоположном случае. Они \--- часть группы из нескольких функций, которые допускаются в охранных выражениях и называются <<встроенными функциями для тестирования типов>>:
\begin{lstlisting}[style=erlang]
is_atom/1           is_binary/1        
is_bitstring/1      is_boolean/1        is_builtin/3       
is_float/1          is_function/1       is_function/2      
is_integer/1        is_list/1           is_number/1        
is_pid/1            is_port/1           is_record/2        
is_record/3         is_reference/1      is_tuple/1        
\end{lstlisting}

Их можно использовать так же как и любое другое охранное выражение, в любом месте, где допускается охранное выражение. Вы, вероятно, задаёте себе вопрос: почему функция просто не возвращает тип терма, который ей передали (что\--то вроде \ops{type\_of(X) -> Type}). Ответ довольно прост. Erlang концентрируется на программировании для правильных случаев: вы составляете программу только для событий, которые точно должно произойти, для тех событий, которые вы ожидаете. Всё прочее должно как можно раньше вызвать ошибку. Может быть это покажется абсурдом, но объяснения, которые вы получите в главе \ref{errors_and_exceptions}, я надеюсь, прояснят ситуацию. А пока что просто поверьте мне на слово.\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} встроенные функции определения типа более чем на половину состоят из инструкций, которые можно использовать в охранных выражениях. Остальные функции также являются встроенными, но не относятся к функциям определения типов. Среди них: \ops{abs(Number), bit\_size(Bitstring), byte\_size(Bitstring),}
\ops{element(N, Tuple), float(Term), hd(List), length(List),}
\ops{node(), node(Pid|Ref|Port), round(Number), self(),}
\ops{size(Tuple|Bitstring), tl(List), trunc(Number), tuple\_size(Tuple).}\\
Функции \ops{node/1} и \ops{self/0} принадлежат к распределённым средствам Erlang и разделу процессов/акторов. Вскоре мы будем их использовать, но до той поры нам нужно изучить много других тем.
    \end{minipage}
}

Может показаться, что структуры данных в Erlang относительно ограничены, но списков и кортежей обычно достаточно для создания других более сложных структур. Например, узел двоичного дерева можно представить как \ops{\{node, Value, Left, Right\}}, где \emph{Left} и \emph{Right} это или узлы, одинаковые по структуре, или пустые кортежи. Я мог бы представить себя в таком виде:
\begin{lstlisting}[style=erlang]
{person, {name, <<"Fred T-H">>},
    {qualities, ["handsome", "smart", "honest", "objective"]},
    {faults, ["liar"]},
    {skills, ["programming", "bass guitar", "underwater breakdancing"]}}.
\end{lstlisting}

Этот пример показывает, что мы можем получить сложные структуры данных путём вложения списка в кортежи, заполнения их данными, и создания функций, которые будут работать над этой структурой.\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Дополнение:} в релизе R13B04 появилась встроенная функция \ops{binary\_to\_term/2}, которая позволяет десериализовать данные так же, как это делает \ops{binary\_to\_term/1}, с тем лишь отличием, что вторым аргументом передаётся список опций. Если передать опцию \ops{[safe]}, то двоичные данные не будут декодированы, если они содержат неизвестные атомы или \ref{higher_order_functions} анонимные функции, которые могут привести к исчерпанию памяти.
    \end{minipage}
}
\section{Для подсевших на типы}
Этот раздел предназначен для программистов, которые не могут жить без статических систем типов по той или иной причине. Он содержит слегка усложнённую теорию, которая не всем будет ясна. Я кратко опишу инструменты, которые используются для статического анализа типов в Erlang, определения специализированных типов, и то, как всё это позволяет получить более безопасный код. Эти инструменты будут описаны в книге намного позже, потому как они совсем не обязательны для разработки надёжных программ на Erlang. Так как мы будем рассматривать их позже, я дам лишь основную информацию об их установке, запуске и т.д. Повторюсь: этот раздел предназначен для тех, кто действительно не может жить без развитых систем типов.
\begin{figure}[h!]
    \includegraphics[width=0.4\textwidth]{type-dance.png}
\end{figure} 

На протяжении нескольких лет предпринимались попытки построения системы типов поверх Erlang. Одна из таких попыток случилась в 1997 году под руководством Simon Marlow, одного из ведущих разработчиков Glasgow Haskell Compiler и Philip Wadler, который работал над проектированием Haskell и внёс свою лепту в теорию, которая лежит в основе монад (\href{http://www.haskell.org/~simonmar/papers/erltc.pdf}{вы можете прочитать документ} посвящённый упомянутой системе типов). Joe Armstrong позже \href{http://www.cs.chalmers.se/Cs/Grundutb/Kurser/ppxt/HT2007/general/languages/armstrong-erlang\_history.pdf}{прокомментировал документ}:\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
Однажды мне позвонил Фил и заявил, что а) Erlang необходима система типов, б) он написал непольшой прототип такой системы и в) у него есть возможность взять годичный отпуск, в течение которого он собирался написать систему типов для Erlang, и спрашивал: <<заинтересованы ли мы в этом?>>. Я ответил: <<Да.>>\\
Phil Wadler и Simon Marlow работали над системой типов больше года, и результаты были опубликованы в [20]. Результаты немного разочаровывали. Начнём с того, что на соответствие типов можно было проверять лишь подмножество языка, большим упущением было отсутствие типизированных процессов и отсутствие проверки типов для сообщений, передаваемых между процессами.
    \end{minipage}
}

Процессы и сообщения относятся к основным средствам Erlang. Может быть именно поэтому система так никогда и не была добавлена в язык. Были и другие неудачные попытки типизировать Erlang. В результате усилий проекта HiPE (попытка увеличить производительность Erlang) появился Dialyzer, инструмент статического анализа, который используется до сих пор. Он имеет свой собственный механизм вывода типов (type inference).

Система типов, которая в нём используется, основана на успешных типизациях (success typings) \--- концепции, которая отличается от системы типов Hindley\--Milner или мягкой типизации (soft\--typing). Концепция успешной типизации проста: метод определение типов не будет пытаться найти точный тип каждого выражения, но он будет гарантировать, что выведенные им типы точны, и что ошибки типов, которые он находит, действительно являются ошибками.

В качестве примера лучше всего привести реализацию функции \ops{and}, которая обычно принимает два булевых значения и возвращает 'true', если оба параметра истинны, иначе возвращается 'false'. В системе типов Haskell это можно записать как \ops{and :: bool -> bool -> bool}. Если бы нужно было реализовать функцию \ops{and} на Erlang, то это можно было бы сделать следующим образом:
\begin{lstlisting}[style=erlang]
and(false, _) -> false;
and(_, false) -> false;
and(true,true) -> true.
\end{lstlisting}

Применяя метод успешной типизации, выведенный тип был бы \ops{and(\_,\_) -> bool()}, где \_ означает 'что угодно'. Это происходит по простой причине: когда запускается программа на Erlang и вызывается эта функция с аргументами \ops{false} и \ops{42}, будет возвращён результат 'false'. Использование шаблона подстановки \ops{\strut\_} в сопоставлении с образцом привело к тому, что для работы функции достаточно передать хотя бы один аргумент, который равен 'false'. У системы типов ML случился бы припадок (а у её пользователей сердечный приступ), если бы вы вызвали функцию таким образом. Но не у Erlang. В этом появится больше смысла, если вы решите прочитать документ про \href{http://www.it.uu.se/research/group/hipe/papers/succ\_types.pdf}{реализацию успешной типизации}, в котором объясняется логика, которая стоит за таким поведением. Я призываю любого наркомана, зависимого от типов, прочитать эту статью. Она представляет собой интересное и полезное описание реализации метода.

Подробности об определениях типов и аннотациях функций описаны в Предложении об Улучшении Erlang №8 (\href{http://www.erlang.org/eeps/eep-0008.html}{EEP8}). Если вас заинтересовало использование успешной типизации в Erlang, взгляните на \href{http://user.it.uu.se/~tobiasl/publications/typer.pdf}{приложение TypEr} и Dialyzer. Оба входят в стандартный дистрибутив. Чтобы ими воспользоваться, введите \ops{\$ typer --help} и \ops{\$ dialyzer --help} (для Windows команды \ops{typer.exe --help} и \ops{dialyzer --help}, если они доступны из текущей директории).

TypEr используется для создания аннотаций типов для функций. Запуск TypEr для этой маленькой \href{http://learnyousomeerlang.com/static/erlang/fifo.erl}{реализации FIFO очереди}, генерирует следующее описание типов:
\begin{lstlisting}[style=erlang]
%% File: fifo.erl
%% --------------
-spec new() -> {'fifo',[],[]}.
-spec push({'fifo',_,_},_) -> {'fifo',nonempty_maybe_improper_list(),_}.
-spec pop({'fifo',_,maybe_improper_list()}) -> {_,{'fifo',_,_}}.
-spec empty({'fifo',_,_}) -> bool().
\end{lstlisting}

Что, в целом, верно. Неправильные списки лучше не использовать, так как \ops{lists:reverse/1} их не поддерживает, а кто\--либо, минуя интерфейс модуля, сможет всё\--таки протолкнуть такой список. В этом случае функции \ops{push/2} и \ops{pop/2} всё же успешно отработают несколько вызовов, перед тем как будет выброшено исключение. Это говорит нам, что необходимо добавить стражи, либо вручную оптимизировать наши определения типов. Предположим, мы добавили в модуль сигнатуру \ops{-spec push(\{fifo,list(),list()\},\_) -> \{fifo,nonempty\_list(),list()\}.} и функцию, которая передаёт неправильный список для \ops{push/2}. При сканировании Dialyzer\--ом (который проверяет типы на соответствие), будет выведено сообщение об ошибке <<The call fifo:push({fifo,[1|2],[]},3) breaks the contract '<Type definition here>\'>>.
\begin{figure}[h!]
    \includegraphics[width=0.4\textwidth]{fifo.png}
\end{figure} 

Dialyzer будет сообщать об ошибках лишь в том случае, когда код будет ломать другой код, и эти сообщения обычно будут оказываться верными (также он будет сообщать и о других проблемах, например о ветках, до которых никогда не дойдёт исполнение или об общем рассогласовании). При помощи Dialyzer\--а также можно анализировать полиморфные типы данных. Функцию \ops{hd()} можно описать при помощи \ops{-spec([A]) -> A.} и корректно проанализировать, впрочем программисты на Erlang редко используют этот синтаксис описания типов.\\
\colorbox{lorange}
{
    \begin{minipage}{\linewidth}
        \textbf{Не забывайтесь:}\\
Dialyzer и TypEr не обрабатывают типовые классы с конструкторами, типы первого порядка и рекурсивные типы. Типы в Erlang \--- это лишь аннотация, которая не влияет и не ограничивает компиляцию, кроме случаев, когда вы сами накладываете эти ограничения. Программа проверки типов никогда не сообщит вам, что в приложении, которое исполняется прямо сейчас (или исполняется уже на протяжении двух лет), есть ошибка типов, которая никак себя не проявляет во время исполнения (впрочем, код с ошибками может корректно исполняться\ldots)\\
Было бы весьма интересно иметь возможность создания рекурсивных типов, но они вряд ли когда\--нибудь появятся для текущей формы TypEr и Dialyzer (объяснение содержит статья, указанная выше). Лучшее, что можно сделать на текущий момент, это симулировать рекурсивные типы при помощи нескольких уровней вложенности, добавленных вручную.\\
Конечно же, нельзя это называть всеобъемлющей системой типов, сравнимой со строгостью и мощью систем, которые предлагают Scala, Haskell или OCaml. Её сообщения о предупреждениях и ошибках обычно слегка запутаны и не всегда ясны пользователю. Тем не менее, это решение предлагает очень неплохой компромисс, если вы просто не можете существовать в мире динамического языка или жаждете дополнительной надёжности. Относитесь к этому как к инструменту в вашем арсенале, не более.
    \end{minipage}
}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Дополнение:}\\
Начиная с версии R13B04, в Dialyzer была добавлена экспериментальная возможность работы с рекурсивными типами. Этот факт делает предыдущий раздел отчасти неверным. Стыд мне и позор.\\
Также заметьте, что \href{http://erlang.org/doc/reference\_manual/typespec.html}{документация типов стала официальной} (хотя она и сможет в будущем измениться) и более полной, чем в EEP8.
    \end{minipage}
}
\chapter{Рекурсия}
\label{recursion}
\section{Привет, рекурсия!}
\begin{wrapfigure}{r}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{reCURSE.png}
\end{wrapfigure}
Некоторые читатели, знакомые с императивными и объектно\--ориентированными языками программирования, должно быть, недоумевают, почему до сих пор не были показаны циклы. Ответить на это можно вопросом: <<Что такое цикл?>> По правде говоря, функциональные языки программирования обычно не предлагают средства построения циклов, такие как \ops{for} и \ops{while}. Вместо них программисты\--функциональщики полагаются на незамысловатую концепцию, именуемую \emph{рекурсией}.

Вы, должно быть, помните как во вводной главе объяснялись неизменяемые переменные. Если не помните, то уделите им \ref{invariable_variables}{~ещё немного внимания}! Рекурсию тоже можно объяснить при помощи математических концепций и функций. Хорошим примером функции, которую можно выразить в рекурсивном виде, может послужить примитивная функция вычисления факториала. Факториал числа \emph{n} это произведение последовательности \ops{$1\times 2\times3\times\ldots\times\emph{n}$} или \ops{$n\times n-1 \times n-2\times\ldots\times 1$}. Например, факториал числа 3 равен \ops{$3! = 3 \times 2 \times 1 = 6$}. Факториал 4 равен \ops{$4! = 4 \times 3 \times 2 \times 1 = 24$}. Эту функцию можно выразить при помощи математической записи в следующем виде:
\[
n! =
  \begin{cases}
   1           & \text{if } x = 0 \\
   n((n - 1)!) & \text{if } x < 0
  \end{cases}
\]

Это означает, что если n равно 0, то в качестве результата возвращается 1. Для любого значения больше 0 возвращается \emph{n} умноженное на факториал \ops{n - 1}, значение которого тоже раскрывается, до тех пор, пока не достигнет 1.
\begin{align*}
4! &= 4 \times 3! \\
4! &= 4 \times 3 \times 2! \\
4! &= 4 \times 3 \times 2 \times 1! \\
4! &= 4 \times 3 \times 2 \times 1 \times 1 \\
\end{align*}

Как же записать такую математическую функцию на Erlang? Очень просто. Взгляните на части записи: \ops{n!}, 1 и \ops{n((n-1)!)}, а затем на \ops{if}\--ы. Мы можем различить имя функции (\ops{n!}), стражей (им соответствуют \ops{if}\--ы) и тело функции (1 и \ops{n((n-1)!)}). Мы переименуем \ops{n!} в \ops{fac(N)}, чтобы немного ограничить наш синтаксис, и получим следующее:
\begin{lstlisting}[style=erlang]
-module(recursive).
-export([fac/1]).
 
fac(N) when N == 0 -> 1;
fac(N) when N > 0  -> N*fac(N-1).
\end{lstlisting}

Вот функция для вычисления факториала и готова! Она очень похожа на математическое определение. Применяя сопоставление с образцом, мы можем немного сократить её объявление:
\begin{lstlisting}[style=erlang]
fac(0) -> 1;
fac(N) when N > 0 -> N*fac(N-1).
\end{lstlisting}

Для математического определения, которое рекурсивно по своей природе, трансляция на Erlang происходит просто и быстро. Мы записали цикл! Определение рекурсивной функции можно сократить до <<функция, которая вызывает саму себя>>. Также нам необходимо определить условие остановки вычислений (это называется базовым случаем), так как без такого условия мы будем находиться в цикле бесконечно. В нашем примере условие остановки \--- это состояние, когда \emph{n} равно 0. В момент, когда это условие истинно, мы перестаём вызывать функцию, и её исполнение прекращается. 
\section{Длина}
\label{length}
Попробуем перейти к более практичным вещам. Напишем функцию, которая считает количество элементов, содержащихся в списке. Сразу же ясно, что нам понадобится:\\
\begin{itemize}
\item базовый случай;
\item функция, которая вызывает сама себя;
\item список, к которому мы применим нашу функцию.
\end{itemize}

Мне кажется, что для большинства рекурсивных функций проще всего сначала записать базовый случай. Что представляет собой самый простой входящий параметр, для которого мы можем найти длину? Это, конечно же, пустой список, длина которого равна 0. Поэтому запомним, что \ops{[] = 0}. Следующий по простоте список имеет длину 1: \ops{[\_] = 1}. Похоже, у нас есть всё необходимое, чтобы записать определение нашей функции:
\begin{lstlisting}[style=erlang]
len([]) -> 0;
len([_]) -> 1.
\end{lstlisting}

Прекрасно! Мы можем подсчитать длину списка, если он содержит 0 либо 1 элемент! Очень полезная возможность. Правда, пользы в ней не так много, потому что ей не хватает рекурсивности. Это приводит нас к самому сложному моменту: нам необходимо расширить функцию таким образом, чтобы она вызывала сама себя для списков с длиной больше 0 и 1. Ранее мы \ref{lists}{~упоминали}, что списки определяются рекурсивно как \ops{[1 | [2| \ldots [n| []]]]}. Это означает, что мы можем использовать образец \ops{[H|T]} для сопоставления со списками одного и более элементов, так как список с одним элементом можно определить как \ops{[X|[]]}, а список с двумя элементами как \ops{[X|[Y|[]]]}. Обратите внимание, что второй элемент сам является списком. Поэтому нам нужно посчитать лишь первый элемент, а потом функция может вызвать себя для второго элемента. Если учесть, что каждый элемент в списке прибавляет к длине 1, то функцию можно переписать в следующем виде:
\begin{lstlisting}[style=erlang]
len([]) -> 0;
len([_|T]) -> 1 + len(T).
\end{lstlisting}

Вот у нас и появилась рекурсивная функция, которая определяет длину списка. Давайте посмотрим как она будет вести себя при исполнении. Попробуем применить её, например, к списку \ops{[1,2,3,4]}: \begin{align*}
len([1,2,3,4]) &= len([1 | [2,3,4])\\
&= 1 + len([2 | [3,4,]])\\
&= 1 + 1 + len([3 | [4]])\\
&= 1 + 1 + 1 + len([4 | []])\\
&= 1 + 1 + 1 + 1 + len([])\\
&= 1 + 1 + 1 + 1 + 0\\
&= 1 + 1 + 1 + 1\\
&= 1 + 1 + 2\\
&= 1 + 3\\
&= 4
\end{align*}
Мы получили верный результат. Поздравляю вас с первой полезной рекурсивной функцией на Erlang!
\section{Длина хвостовой рекурсии}
\label{length_of_a_tail_recursion}

\begin{wrapfigure}{l}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{tail-recursion.png}
\end{wrapfigure}
Возможно, вы заметили, что для списка из четырёх термов, мы разложили вызов нашей функций на цепь из пяти операций суммирования. Хотя этот принцип хорошо работает для коротких списков, он может создать проблемы для случая, когда ваш список содержит несколько миллионов значений. Для такого простого вычисления совсем не обязательно хранить в памяти миллионы чисел. Это слишком расточительно, к тому же, есть способ получше. Познакомьтесь с \emph{хвостовой рекурсией}.

Хвостовая рекурсия \--- это способ трансформации вышеописанного линейного процесса (который растёт прямо пропорционально количеству элементов) в итеративный (в котором никакого роста нет вообще). Чтобы вызов функции стал хвостовым, он должен быть <<одиночным>>. Здесь необходимо пояснить: наши предыдущие вызовы росли из\--за того, что результат первого вызова зависел от вычисления второго. Чтобы найти ответ для \ops{1 + len(Rest)}, необходимо вычислить результат \ops{len(Rest)}. А для вычисления \ops{len(Rest)}, в свою очередь, понадобиться найти результат ещё одного вызова функции. Операции суммирования будут накапливаться до тех пор, пока не будет найден результат последней, и только после этого можно будет вычислить конечный результат. Хвостовая рекурсия позволяет избавиться от этого накопления посредством вычисления операций по мере их возникновения.

Чтобы этого добиться, нам необходимо завести временную переменную и передавать её при каждом вызове функции в качестве дополнительного параметра. Я проиллюстрирую эту концепцию при помощи функции вычисления факториала. На этот раз определим её с использованием хвостовой рекурсии. Вышеупомянутую временную переменную иногда называют \emph{аккумулятором}. Для ограничения роста вызовов нашей функции, мы сохраняем в аккумуляторе результаты вычислений, по мере того как они происходят:
\begin{lstlisting}[style=erlang]
tail_fac(N) -> tail_fac(N,1).
 
tail_fac(0,Acc) -> Acc;
tail_fac(N,Acc) when N > 0 -> tail_fac(N-1,N*Acc).
\end{lstlisting}

Я определил две функции \ops{tail\_fac/1} и \ops{tail\_fac/2}. Сделал я это по причине того, что Erlang не позволяет указывать для параметров значения по умолчанию (функции c разной арностью, которые имеют одинаковые имена \--- это разные функции), поэтому мы создаём аналогичный эффект вручную. В данном случае \ops{tail\_fac/1} реализует абстракцию поверх функции \ops{tail\_fac/2}, которая использует хвостовую рекурсию. Никого не интересуют детали реализации скрытого аккумулятора, который использует \ops{tail\_fac/2}, поэтому мы будем экспортировать из модуля лишь \ops{tail\_fac/1}. Исполнение функции можно записать в следующем виде:
\begin{align*}
tail\_fac(4) &= tail\_fac(4,1)\\
tail\_fac(4,1) &= tail\_fac(4-1, 4*1)\\
tail\_fac(3,4) &= tail\_fac(3-1, 3*4)\\
tail\_fac(2,12) &= tail\_fac(2-1,2*12)\\
tail\_fac(1,24) &= tail\_fac(1-1, 1*24)\\
tail\_fac(0,24) &= 24
\end{align*}

Видите разницу? Теперь нам не нужно держать в памяти одновременно более двух термов. Количество места, выделяемого под хранение данных, не меняется. Для вычисления факториала числа 4 понадобится столько же места, сколько для вычисления факториала 1000000 (если не учитывать, что 4! занимает в числовом представлении намного меньше места, чем 1000000!).

Теперь, когда вы видели функцию вычисления факториала с использованием хвостовой рекурсии, вам, наверняка, ясно как этот шаблон можно применить к нашей функции \ops{len/1}. Необходимо лишь сделать так, чтобы к результату рекурсивного вызова больше не применялись никакие операции. Для тех, кто любит визуальные примеры, представьте, что вы помещаете операцию \ops{+1} внутрь вызова функции путём добавления к параметру:
\begin{lstlisting}[style=erlang]
len([]) -> 0;
len([_|T]) -> 1 + len(T).
\end{lstlisting}
принимает вид:
\begin{lstlisting}[style=erlang]
tail_len(L) -> tail_len(L,0).
 
tail_len([], Acc) -> Acc;
tail_len([_|T], Acc) -> tail_len(T,Acc+1).
\end{lstlisting}

Теперь ваша функция вычисления длины списка использует хвостовую рекурсию.
\section{Снова рекурсивные функции}
\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{rock-paper-scissors.png}
\end{wrapfigure}
Чтобы немного привыкнуть к рекурсивным функциям, мы напишем ещё несколько. В конце концов, рекурсия \--- это единственный способ организации итераций, который существует в Erlang (кроме списковых выражений), поэтому эту концепцию очень важно понимать. Это знание будет также полезно для любого другого функционального языка программирования, с которым вы можете столкнуться позже, поэтому запоминайте!

Первая функция, которую мы напишем \--- \ops{duplicate/2}. Она принимает первым параметром целое число, а вторым \--- произвольный терм. Затем она создаёт список, который содержит столько копий терма, сколько указано в первом параметре. Как и ранее, для начала неплохо подумать о базовом случае. Самое простое, что может сделать функция \ops{duplicate/2}, это повторить что\--либо 0 раз. Для этого она должна просто возвратить пустой список, не учитывая передаваемый терм. В любом другом случае мы должны пытаться добраться до базового путём рекурсивного вызова функции. Вдобавок, мы запретим целому параметру принимать отрицательные значения, потому что нельзя повторить что\--либо \ops{-n} раз:
\begin{lstlisting}[style=erlang]
duplicate(0,_) ->
    [];
duplicate(N,Term) when N > 0 ->
    [Term|duplicate(N-1,Term)].
\end{lstlisting}

Как только мы определили основную рекурсивную функцию, её становится проще записать в виде, который использует хвостовую рекурсию. Делается это путём перемещения операции создания списка во временную переменную:
\begin{lstlisting}[style=erlang]
tail_duplicate(N,Term) ->
    tail_duplicate(N,Term,[]).
 
tail_duplicate(0,_,List) ->
    List;
tail_duplicate(N,Term,List) when N > 0 ->
    tail_duplicate(N-1, Term, [Term|List]).
\end{lstlisting}

Получилось! Теперь я хотел бы немного изменить предмет обсуждения, чтобы обозначить связь между хвостовой рекурсией и циклом while. Наша функция \ops{tail\_duplicate/2} содержит все части, которые присущи циклу while. Если бы мы представили себе цикл while в выдуманном языке с синтаксисом похожим на Erlang, то наша функция могла бы выглядеть следующим образом:
\begin{lstlisting}[style=erlang]
function(N, Term) ->
    while N > 0 ->
        List = [Term|List],
        N = N-1
    end,
    List.
\end{lstlisting}

Обратите внимание, что все элементы цикла присутствуют как в воображаемом языке, так и в Erlang. Отличается лишь их расположение. Это показывает, что правильно написанная функция, использующая хвостовую рекурсию, подобна итеративному процессу, такому как цикл while.

Есть также ещё одно интересное свойство, которое мы <<откроем>> путём сравнении рекурсивной функции и функции с хвостовой рекурсией. Мы напишем функцию \ops{reverse/1}, которая будет разворачивать список термов задом\--наперёд. Базовым случаем в этой функции является пустой список, для которого разворачивать нечего. Для пустого списка мы можем просто вернуть пустой список. В любой другой ситуации функция должна сходиться к базовому случаю, вызывая саму себя, как это было в \ops{duplicate/2}. Наша функция будет перебирать элементы списка при помощи сопоставления с образцом \ops{H|T]}, а потом добавлять \emph{H} в конец списка:
\begin{lstlisting}[style=erlang]
reverse([]) -> [];
reverse([H|T]) -> reverse(T)++[H].
\end{lstlisting}

Для длинных списков это может оказаться настоящим кошмаром: помимо проблемы наслаивания функций добавления, нам придётся для каждой операции добавления в конец списка проходить список полностью от начала до конца! Визуально это можно представить как:
\begin{align*}
reverse([1,2,3,4]) &= [4]++[3]++[2]++[1]\\
&= [4,3]++[2]++[1]\\
&= [4,3,2]++[1]\\
&= [4,3,2,1]\\
\end{align*}

На помощь к нам приходит хвостовая рекурсия. Мы будем добавлять к аккумулятору новый головной элемент на каждой итерации. Это автоматически развернёт список в противоположном направлении. Посмотрим на реализацию:
\begin{lstlisting}[style=erlang]
tail_reverse(L) -> tail_reverse(L,[]).
 
tail_reverse([],Acc) -> Acc;
tail_reverse([H|T],Acc) -> tail_reverse(T, [H|Acc]).
\end{lstlisting}

Если мы распишем шаги исполнения этой функции, то получим:
\begin{align*}
tail\_reverse([1,2,3,4]) &= tail\_reverse([2,3,4], [1])\\
&= tail\_reverse([3,4,], [2,1])\\
&= tail\_reverse([4], [3,2,1])\\
&= tail\_reverse([], [4,3,2,1])\\
&= [4,3,2,1]
\end{align*}

Можно заметить, что теперь мы посещаем линейное количество элементов. Наш стек не будет расти, и эффективность выполнения операций добавления элементов в этом случае намного выше!

Реализуем ещё одну функцию \--- \ops{sublist/2}. Она принимает список \emph{L} и целое число \emph{N}, и возвращает первых \emph{N} элементов из списка. Например, вызов \ops{sublist([1,2,3,4,5,6],3)} возвратит [1,2,3]. И снова базовый случай \--- попытка получить 0 элементов из списка. Впрочем, будьте осторожны, так как в случае \ops{sublist/2} есть отличия. Есть и второй базовый случай, в котором передаётся пустой список! Если мы не сделаем проверку списка на пустоту, то при вызове \ops{recursive:sublist([1],2).} будет выброшена ошибка, хотя в качестве результата мы ожидали получить \ops{[1]}. Как только мы разобрались с этими проблемами, рекурсивной части функции остаётся лишь пройти по списку, сохраняя элементы до тех пор, пока она не упрётся в один из базовых случаев:
\begin{lstlisting}[style=erlang]
sublist(_,0) -> [];
sublist([],_) -> [];
sublist([H|T],N) when N > 0 -> [H|sublist(T,N-1)].
\end{lstlisting}

Функцию можно привести к форме с использованием хвостовой рекурсии тем же путём, что и прежде:
\begin{lstlisting}[style=erlang]
tail_sublist(L, N) -> tail_sublist(L, N, []).
 
tail_sublist(_, 0, SubList) -> SubList;
tail_sublist([], _, SubList) -> SubList;
tail_sublist([H|T], N, SubList) when N > 0 ->
tail_sublist(T, N-1, [H|SubList]).
\end{lstlisting}

Но в этой функции есть изъян. Роковой изъян! Мы используем в качестве аккумулятора список, так же как мы это делали, когда разворачивали список задом\--наперёд. Если вы сейчас скомпилируете функцию, то вызов \ops{sublist([1,2,3,4,5,6],3)} возвратит не [1,2,3], а [3,2,1]. Поэтому нам нужно взять окончательный результат и развернуть его самостоятельно. Просто поменяйте вызов \ops{tail\_sublist/2}, а рекурсивную логику оставьте прежней:
\begin{lstlisting}[style=erlang]
tail_sublist(L, N) -> reverse(tail_sublist(L, N, [])).
\end{lstlisting}

Окончательный результат будет упорядочен правильно. Может показаться, что разворот списка после вызова хвостовой рекурсии \--- напрасная потеря времени, и это отчасти правда (таким образом мы всё равно экономим память). Вы сможете заметить, что из\--за необходимости разворота, на коротких списках ваш код с использованием обычной рекурсии работает быстрее, чем код с хвостовой рекурсией. Но по мере увеличения объёма данных, на фоне остальных операций разворачивание списка будет значить всё меньше и меньше.\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} вместо собственноручно написанной функции \ops{reverse/1} вы должны использовать \ops{lists:reverse/1}. Функция так часто использовалась для вызовов с хвостовой рекурсией, что разработчики Erlang решили превратить её во встроенную. Списки будут разворачиваться чрезвычайно быстро (благодаря тому, что функция написана на языке C), что сделает замедление, которое вносит разворот, менее заметным. Остальной код в этой главе будет использовать нашу собственную функцию разворота элементов, но больше вы её никогда использовать не должны.
    \end{minipage}
}

Чтобы немного развить тему, мы напишем zip\--функцию. Такая функция принимает в качестве параметров два списка одинаковой длины и попарно комбинирует их элементы в виде списка кортежей. Наша функция \ops{zip/2} будет вести себя следующим образом:
\begin{lstlisting}[style=erlang]
1> recursive:zip([a,b,c],[1,2,3]).
[{a,1},{b,2},{c,3}]
\end{lstlisting}

Так как мы хотим, чтобы оба параметра имели одинаковую длину, нашим базовым случаем будет комбинирование двух пустых списков:
\begin{lstlisting}[style=erlang]
zip([],[]) -> [];
zip([X|Xs],[Y|Ys]) -> [{X,Y}|zip(Xs,Ys)].
\end{lstlisting}

Однако, если вы хотите, чтобы функция мягче относилась к параметрам, лучше позволить ей заканчивать обработку, когда опустеет один из списков. Для такого сценария у вас появится два базовых случая:
\begin{lstlisting}[style=erlang]
lenient_zip([],_) -> [];
lenient_zip(_,[]) -> [];
lenient_zip([X|Xs],[Y|Ys]) -> [{X,Y}|lenient_zip(Xs,Ys)].
\end{lstlisting}

Обратите внимание, что вне зависимости от того, какие мы определяем базовые случаи, рекурсивная часть функции остаётся неизменной. Я бы посоветовал вам попробовать написать собственные версии \ops{zip/2} и \ops{lenient\_zip/2} с использованием хвостовой рекурсии, чтобы убедиться, что вы полностью понимаете как создаются такие функции. Хвостовая рекурсия будет одной из центральных концепций, лежащих в основе большого приложения, главный цикл которого будет организован именно таким образом.

Если хотите проверить то, что у вас получилось, взгляните на мою реализацию в \href{http://learnyousomeerlang.com/static/erlang/recursive.erl}{recursive.erl}, а именно на функции \ops{tail\_zip/2} и \ops{tail\_lenient\_zip/3}.
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} хвостовая рекурсия не раздувает используемую память, так как виртуальная машина видит, что рекурсивный вызов происходит из хвостовой позиции (последнее выражение, которое обрабатывает функция), и устраняет текущий стековый кадр. Эта техника называется оптимизацией хвостового вызова и является специальным случаем более общей оптимизации под названием \emph{оптимизация последнего вызова}.\\
Оптимизация последнего вызова происходит, когда последнее выражение в теле функции является ещё одним вызовом функции. В этом случае, как и в случае оптимизации хвостовой рекурсии, виртуальная машина Erlang не сохраняет стековый кадр. Поэтому хвостовая рекурсия возможна между несколькими функциями. Например, цепь функций \ops{a() -> b(). b() -> c(). c() -> a().} создаст в результате бесконечный цикл, который не приведт к исчерпанию памяти, так как оптимизация последнего вызова предотвращает переполнение стека. Этот принцип в сочетании с использованием аккумуляторов делает хвостовую рекурсию полезной техникой.
    \end{minipage}
}
\section{Быстро, сортируй!}
\begin{wrapfigure}{l}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{quicksort.png}
\end{wrapfigure}
Я могу (и буду) считать, что рекурсия и хвостовая рекурсия вам ясна. Но просто чтобы в этом убедиться, я приведу более сложный пример \--- реализацию алгоритма быстрой сортировки. Да, традиционный <<эй, смотри, я могу писать сжатый функциональный код>> канонический пример. Наивная реализация алгоритма быстой сортировки выбирает первый элемент списка, \emph{опорный элемент}, и перемещает все элементы меньшие, либо равные опорному элементу в новый список, а все элементы больше опорного элемента \--- в другой список. Затем мы повторяем эту процедуру для полученных списков. Этот процесс продложается до тех пор, пока для сортировки не останется ничего, кроме пустых списков, которые и станут нашим базовым случаем. Эта реализация считается простой, потому что более эффективные версии быстрой сортировки будут пытаться выбрать оптимальные опорные элементы с целью ускорения. Впрочем, в нашем примере это не столь важно.

Нам понадобятся две функции: первая будет разбивать список на части, содержащие меньшие и большие элементы, а вторая будет применять функцию разбиения к новым спискам и соединять их в единое целое. Для начала мы напишем функцию соединения:
\begin{lstlisting}[style=erlang]
quicksort([]) -> [];
quicksort([Pivot|Rest]) ->
{Smaller, Larger} = partition(Pivot,Rest,[],[]),
quicksort(Smaller) ++ [Pivot] ++ quicksort(Larger).
\end{lstlisting}

Здесь мы видим: базовый случай; список, который разбит при помощи ещё одной функции на части с большими и меньшими элементами; опорный элемент, к которому слева и справа присоединены отсортированные списки. Этот код отвечает за соединение списков. Перейдём к функции разбиения:
\begin{lstlisting}[style=erlang]
partition(_,[], Smaller, Larger) -> {Smaller, Larger};
partition(Pivot, [H|T], Smaller, Larger) ->
    if H =< Pivot -> partition(Pivot, T, [H|Smaller], Larger);
        H >  Pivot -> partition(Pivot, T, Smaller, [H|Larger])
    end.
\end{lstlisting}

Теперь функцию быстрой сортировки можно запустить. Если вы искали в Интернет примеры программ на Erlang, то, скорее всего, наталкивались на другую реализацию быстрой сортировки, ту, которая выглядит проще и легче читается, но использует списковые выражения. Их легко можно применить в месте, где создаются новые списки, в функции \ops{partition/4}:
\begin{lstlisting}[style=erlang]
lc_quicksort([]) -> [];
lc_quicksort([Pivot|Rest]) ->
    lc_quicksort([Smaller || Smaller <- Rest, Smaller =< Pivot])
    ++ [Pivot] ++
    lc_quicksort([Larger || Larger <- Rest, Larger > Pivot]).
\end{lstlisting}

Главное отличие этой версии в том, что её код легче читать, но за лёгкость чтения приходится платить тем, что для разбиения списка, необходимо перебрать все его элементы. В этом проявляется борьба ясности кода против скорости его исполнения. Но проигрываете в этой борьбе лишь вы, потому что для таких ситуаций уже создана функция \ops{lists:sort/1}. Используйте лучше её.\\
\colorbox{lorange}
{
    \begin{minipage}{1.0\linewidth}
\textbf{Не забывайтесь:}\\
Выразительность кода хороша для обучения, но не всегда полезна для производительности. Множество руководств по функциональному программированию ни слова об этом не говорят! Во\--первых, обеим реализациям, приведённым здесь, приходится неоднократно обрабатывать элементы равные опорному элементу. Для увеличения эффективности можно было бы возвращать три списка: элементы меньше, больше и равные опорному элементу.\\
Ещё одна проблема связана с тем, что нам необходимо неоднократно проходить по разбитым спискам при их слиянии с опорным элементом. Можно немного уменьшить накладные расходы, если производить объединение во время разбиения списков на три части. Тем, кто заинтересовался реализацией, я предлагаю взглянуть на последнюю функцию (\ops{bestest\_qsort/1}) из файла \href{http://learnyousomeerlang.com/static/erlang/recursive.erl}{recursive/erl}.\\
Приятно отметить, что все рассмотренные реализации быстрой сортировки будут работать со списками, содержащими любые типы, даже кортежи или что\--то подобное. Попробуйте, они работают!
    \end{minipage}
}
\section{Больше чем списки}
\begin{wrapfigure}{l}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{tree.png}
\end{wrapfigure}
Читая эту главу, вы, возможно, начинаете думать, что рекурсия в Erlang, главным образом, связана со списками. Хотя списки и могут служить хорошим примером структуры, которую можно определить через рекурсию, но на ней, конечно, всё не заканчивается. Мы рассмотрим, для разнообразия, как можно создавать двоичные деревья и считывать из них данные.

Для начала неплохо было бы определить, что такое дерево. В нашем случае оно снизу доверху состоит из узлов. Узлы \--- это кортежи, которые содержат ключ, данные связанные с ключом, и два других узла. Эти два узла мы разделяем на узел с ключом меньшим и большим, чем ключ узла, который их содержит. И вот появляется рекурсия! Дерево \--- это узел, который содержит узлы, каждый из которых содержит узлы, которые, в свою очередь, содержат узлы. Бесконечно это не может продолжаться (у нас нет бесконечного пространства для хранения данных), поэтому мы скажем, что узлы, которые содержатся в наших узлах, также могут быть пустыми.

Кортежи \--- подходящая структура для представления узлов. Для нашей реализации мы определим такие кортежи как \ops{\{node, \{Key, Value, Smaller, Larger\}\}} (меченый кортеж!), где \emph{Smaller} и \emph{Larger} могут быть другим подобным узлом, или пустым узлом (\ops{\{node, nil\}}. Более сложные концепции нам не понадобятся.

Начнём создавать модуль для нашей \href{http://learnyousomeerlang.com/static/erlang/tree.erl}{очень простой реализации дерева}. Первая функция \ops{empty/0} \--- возвращает пустой узел. Пустой узел \--- это начальная точка нового дерева, которая также называется \emph{корневым узлом}:
\begin{lstlisting}[style=erlang]
-module(tree).
-export([empty/0, insert/3, lookup/2]).
 
empty() -> {node, 'nil'}.
\end{lstlisting}

Мы скрываем реализацию, используя эту функцию, и, затем, инкапсулируем её в одинаковое представление узлов, чтобы пользователю не пришлось задумываться о том, как построен наш код. Вся эта информация будет существовать лишь в рамках модуля. Если вам когда\--либо придёт в голову изменить представление узла \--- вы сможете сделать изменения, не нарушая работу внешнего кода.

Для того, чтобы наполнить дерево содержимым, нам необходимо, для начала, понять, как по нему рекурсивно перемещаться. Давайте поступим так же, как мы поступали в любом другом примере с рекурсией \--- попытаемся найти базовый случай. Так как пустое дерево состоит из пустого узла, то, рассуждая логически, нашим базовым случаем будет пустой узел. Мы сможем добавить новую пару ключ/значение, когда наткнёмся на пустой узел. В остальных случаях наш код будет ходить по дереву в поисках пустого узла, который можно наполнить данными.

Мы будем искать пустой узел, начиная с корневого узла. Для этого мы должны использовать знание о том, что \emph{Меньший} и \emph{Больший} узлы позволяют нам определять направление перемещения, сравнивая новый ключ, который необходимо добавить, с ключом текущего узла. Если новый ключ меньше ключа текущего узла, то мы продолжаем искать пустой узел внутри \emph{Меньшего} узла, и если больше, то внутри \emph{Большего}. Нельзя забывать ещё об одном случае: что будет, если новый ключ равен ключу текущего узла? У нас есть две возможности: сгенерировать ошибку, либо заменить значение узла новым. Здесь мы используем замену. Все эти рассуждения, заключённые в код, выглядят следующим образом:
\begin{lstlisting}[style=erlang]
insert(Key, Val, {node, 'nil'}) ->
    {node, {Key, Val, {node, 'nil'}, {node, 'nil'}}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey < Key ->
    {node, {Key, Val, insert(NewKey, NewVal, Smaller), Larger}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey > Key ->
    {node, {Key, Val, Smaller, insert(NewKey, NewVal, Larger)}};
insert(Key, Val, {node, {Key, _, Smaller, Larger}}) ->
    {node, {Key, Val, Smaller, Larger}}.
\end{lstlisting}

Обратите внимание, что функция возвращает совершенно новое дерево. Это характерная черта функциональных языков программирования, в которых присваивание происходит лишь один раз. Хотя это и может показаться неэффективным, но большая часть структур, которые лежат в основе обеих версий дерева, остаются теми же и используются совместно, а поэтому копируются виртуальной машиной лишь по необходимости.

Для завершения этой демонстрационной реализации дерева, нам необходимо создать функцию \ops{lookup/2}, которая позволит найти значение узла по ключу. Мы будем использовать принцип, чрезвычайно похожий на тот, который мы использовали при добавлении новых данных в дерево: мы проходим по узлам дерева, шаг за шагом проверяя, что искомый ключ больше, меньше, либо равен ключу текущего узла. У нас есть два базовых случая: первый \--- когда узел пуст (ключа в дереве нет), и второй \--- когда ключ найден. Мы не хотим, чтобы наша программа сбоила каждый раз, когда мы ищем ключ, который в дереве отсутствует, а поэтому в такой ситуации мы будем возвращать атом 'undefined'. В случае удачи, мы возвращаем \ops{\{ok, Value\}}. Если бы мы просто возвращали \emph{Value}, а искомый узел содержал атом 'undefined', то мы не могли бы понять, было найдено верное значение или нет. Обёртывание успешно найденных результатов позволяет их легко отличать от неудачных. Вот реализация функции:
\begin{lstlisting}[style=erlang]
lookup(_, {node, 'nil'}) ->
    undefined;
lookup(Key, {node, {Key, Val, _, _}}) ->
    {ok, Val};
lookup(Key, {node, {NodeKey, _, Smaller, _}}) when Key < NodeKey ->
    lookup(Key, Smaller);
lookup(Key, {node, {_, _, _, Larger}}) ->
    lookup(Key, Larger).
\end{lstlisting}

Всё, мы закончили. Давайте потестируем нашу структуру \--- напишем небольшую адресную книгу для электронной почты. Скомпилируйте файл и запустите оболочку:
\begin{lstlisting}[style=erlang]
1> T1 = tree:insert("Jim Woodland", "jim.woodland@gmail.com", tree:empty()).
{node,{"Jim Woodland","jim.woodland@gmail.com",
    {node,nil},
    {node,nil}}}
2> T2 = tree:insert("Mark Anderson", "i.am.a@hotmail.com", T1).
{node,{"Jim Woodland","jim.woodland@gmail.com",
    {node,nil},
    {node,{"Mark Anderson","i.am.a@hotmail.com",
        {node,nil},
        {node,nil}}}}}
3> Addresses = tree:insert("Anita Bath", "abath@someuni.edu", tree:insert("Kevin Robert", "myfairy@yahoo.com", tree:insert("Wilson Longbrow", "longwil@gmail.com", T2))).
{node,{"Jim Woodland","jim.woodland@gmail.com",
    {node,{"Anita Bath","abath@someuni.edu",
        {node,nil},
        {node,nil}}},
    {node,{"Mark Anderson","i.am.a@hotmail.com",
        {node,{"Kevin Robert","myfairy@yahoo.com",
            {node,nil},
            {node,nil}}},
        {node,{"Wilson Longbrow","longwil@gmail.com",
            {node,nil},
            {node,nil}}}}}}}
\end{lstlisting}

Теперь можно поискать адреса с помощью нашей книги:
\begin{lstlisting}[style=erlang]
4> tree:lookup("Anita Bath", Addresses).
{ok, "abath@someuni.edu"}
5> tree:lookup("Jacques Requin", Addresses).
undefined
\end{lstlisting}

На этом мы завершаем рассмотрение примера функциональной адресной книги, построенной при помощи рекурсивной структуры данных отличной от списка!\\
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
\textbf{Замечание:} наша реализация весьма примитивна: мы не поддерживаем часто используемые операции, такие как удаление узлов или перебалансировка дерева для ускорения последующих операций поиска. Если вам интересно было бы реализовать и/или изучить эти операции \--- обратитесь к реализации модуля \ops{gb\_trees} (\ops{otp\_src\_R<version>B<revision>/lib/stdlib/src/gb\_trees.erl}). Кроме того, при работе с деревьями используйте именно этот модуль и не пытайтесь изобрести велосипед.
    \end{minipage}
}
\section{Рекурсивное мышление}
Если вы поняли всё сказанное в этой главе, то рекурсивное мышление, вероятно, начинает становиться частью вашей интуиции. Главное отличие рекурсивных определений от их императивных аналогов (обычно это циклы while или for) в том, что вместо пошагового выполнения (<<сделай это, потом то, затем вот это, после этого заверши исполнение>>) мы используем декларативный подход (<<если ты получишь такой входящий параметр, сделай это, в противном случае \--- вот это>>). Это свойство становится более очевидным при использовании сопоставления с образцом в заголовке функции.

Если вы до сих пор не поняли как работает рекурсия, может быть вам нужно прочитать вот \ref{recursion}{~это}.

Отбросив шутки в сторону, нужно признать, что иногда рекурсия в сочетании с сопоставлением с образцом \--- это оптимальный способ записи ясных и понятных алгоритмов. После того как каждая часть задачи поделена на функции, которые не поддаются дальнейшему упрощению, алгоритм превращается в компоновку правильных ответов, исходящих из коротких подпрограмм (что\--то подбное мы делали с быстрой сортировкой). С обычными циклами можно тоже использовать такой тип мысленной абстракции, но на практике это получается лучше именно с рекурсией. Ваш опыт может свидетельствовать об ином.

\textbf{А теперь, леди и джентльмены \--- дискуссия автора с самим собой}

\--- Хорошо, кажется я понял рекурсию. Я понимаю, что она связана с декларативностью, что корни её уходят в математику, как и у неизменяемых переменных. Я понимаю, что в некоторых случаях её проще использовать. Что ещё?

\--- Она имеет регулярную структуру. Найди базовый случай, запиши его. Для получения результата нужно, чтобы любой другой случай сходился к одному из базовых. Так проще записывать функции.

\--- Ага, понял, ты это уже говорил несколько раз. Я то же самое могу сделать циклами.

\--- Да, можешь. Не буду отрицать!

\--- Хорошо. Мне не совсем ясно, зачем ты писал функции, которые не используют хвостовую рекурсию, раз уж они намного хуже тех, что её используют.

\--- А, ну это просто, чтобы было легче понять. Мне показалось, что переход от обычный рекурсии, которая выглядит красивее и проще для понимания, к хвостовой рекурсии, которая теоретически более эффективна, неплохо показал все плюсы и минусы этих подходов.

\--- Хорошо, значит ни для чего кроме обучения они не годятся, я понял.
\begin{wrapfigure}{r}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{fib.png}
\end{wrapfigure}

\--- Это не совсем так. Разница в производительности между функцией с хвостовой рекурсией и обычной рекурсией будет не сильно заметна. Хвостовая рекурсия хорошо подходит для функций, которые итерируют бесконечно, например для главных циклов. Есть также функции, которые порождают очень большой стековый кадр, медленно исполняются и, если их не записывать в виде хвостовой рекурсии, могут рано приводить к аварийному завершению. Неплохим примером может служить задача вычисления \href{http://en.wikipedia.org/wiki/Fibonacci\_number}{чисел Фибоначчи}, сложность которой растёт экспоненциально, если не решать её в виде итеративного процесса или хвостовой рекурсии. Также необходимо профилировать написанный код (позже я покажу как это делать, я обещаю), определять и исправлять места, которые замедляют исполнение.

\--- Но циклы \--- это всегда итеративный процесс, проще использовать их и не знать проблем.

\--- Да, но\ldots но\ldots мой прекрасный Erlang\ldots

\--- Ну, зашибись. Весь сыр\--бор из\--за того, что в Erlang нет <<while>> и <<for>>. Спасибо большое, я пошёл дальше программировать свой тостер на C!

\--- Погоди\--ка! У функциональных языков программирования есть и другие возможности! Кроме шаблона для поиска базовых случаев, который облегчил нам жизнь при написании рекурсивных функций, существует ещё много других шаблонов, которые придумали умные люди. Благодаря этому необходимость самостоятельно писать рекурсивные функции значительно уменьшается. Если ты продолжишь занятия, я покажу как строить такие абстракции. Но для этого нам нужно взять что\--то помощнее. Позволь мне рассказать о функциях высшего порядка\ldots
\chapter{Функции высшего порядка}
\section{Подбавим функциональщины}
\label{higher_order_functions}
\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{lambda.png}
\end{wrapfigure}
Важной частью всех функциональных языков является возможность передачи функции как параметра для другой функции. Это, в свою очередь, связывает параметр\--функцию с переменной, которую можно использовать внутри функции как любую другую. Функция, которая может таким способом принимать другие функции, называется функцией высшего порядка. Функции высшего порядка \--- это мощный способ абстракции и один из лучших инструментов, которым предлагает овладеть Erlang.

Опять же, эта концепция берёт начало в математике, а именно в \href{http://en.wikipedia.org/wiki/Lambda\_calculus}{лямбда\--исчислении}. Не буду углубляться в детали лямбда\--исчисления, потому что эта теория довольно сложна для понимания, и немного выходит за рамки контекста, который мы рассматриваем. Тем не менее, я бы кратко охарактеризовал её как систему, в которой всё представлено в качестве функций, даже числа. Так как любая сущность \--- это функция, то в качестве параметров мы должны передавать функциям другие функции и оперировать ими, опять же, при помощи функций!

Ну ладно, наверняка всё сказанное звучит немного странно, поэтому начнём с примера:
\begin{lstlisting}[style=erlang]
-module(hhfuns).
-compile(export_all).
 
one() -> 1.
two() -> 2.
 
add(X,Y) -> X() + Y().
\end{lstlisting}

А теперь откройте оболочку Erlang, скомпилируйте модуль и посмотрите как он работает:
\begin{lstlisting}[style=erlang]
1> c(hhfuns).
{ok, hhfuns}
2> hhfuns:add(one,two).
** exception error: bad function one
    in function  hhfuns:add/2
3> hhfuns:add(1,2).
** exception error: bad function 1
    in function  hhfuns:add/2
4> hhfuns:add(fun hhfuns:one/0, fun hhfuns:two/0).
3
\end{lstlisting}

Не совсем понятно? Когда разберётесь в принципе работы, сразу станет яснее (всегда так, не правда ли?) В команде под номером 2 атомы \ops{one} и \ops{two} передаются в функцию \ops{add/2}, которая затем использует оба атома в качестве имён для функций (\ops{X() + Y()}). Если имена функций записаны без списка параметров, то эти имена интерпретируются как атомы, а атомы не могут быть функциями, поэтому вызов заканчивается неудачей. По той же причине не удаётся исполнить выражение 3. Значения 1 и 2 тоже невозможно использовать как функции, а нам нужны именно функции!

Поэтому мы должны использовать новый способ записи, который позволит передавать функции, размещённые за пределами модуля. Именно эту задачу выполняет \ops{fun Module:Function/Arity}. Эта строка указывает VM, что та должна взять определённую функцию и привязать её к переменной.

Так что же мы приобретаем, используя функции таким образом? Для понимания рассмотрим маленький пример. Мы добавим в модуль \ops{\href{http://learnyousomeerlang.com/static/erlang/hhfuns.erl}{hhfuns}} пару функций, которые будут рекурсивно проходить по списку и прибавлять или вычитать единицу из каждого элемента:
\begin{lstlisting}[style=erlang]
increment([]) -> [];
increment([H|T]) -> [H+1|increment(T)].
 
decrement([]) -> [];
decrement([H|T]) -> [H-1|decrement(T)].
\end{lstlisting}

Видите как эти функции похожи друг на друга? Они практически делают одно и то же: проходят по списку, применяют к каждому элементу функцию (\ops{+\strut} или \ops{-\strut}) и затем снова вызывают себя. В этом коде практически ничего не меняется кроме применяемой функции и рекурсивного вызова. Для такого рекурсивного вызова над списком, основа всегда остаётся неизменной. Мы абстрагируем все похожие части в единую функцию (\ops{map/2}), которая будет принимать в качестве аргумента ещё одну функцию:
\begin{lstlisting}[style=erlang]
map(_, []) -> [];
map(F, [H|T]) -> [F(H)|map(F,T)].
 
incr(X) -> X + 1.
decr(X) -> X - 1.
\end{lstlisting}

Которую можно протестировать в оболочке:
\begin{lstlisting}[style=erlang]
1> c(hhfuns).
{ok, hhfuns}
2> L = [1,2,3,4,5].
[1,2,3,4,5]
3> hhfuns:increment(L).
[2,3,4,5,6]
4> hhfuns:decrement(L).
[0,1,2,3,4]
5> hhfuns:map(fun hhfuns:incr/1, L).
[2,3,4,5,6]
6> hhfuns:map(fun hhfuns:decr/1, L).
[0,1,2,3,4]
\end{lstlisting}

В этом примере результат вычислений не меняется, но в результате мы получаем изящную абстракцию! Каждый раз, когда вы хотите применить функцию к каждому элементу в списке, вам нужно лишь вызвать \ops{map/2} и передать ей в качестве параметра собственную функцию. Впрочем, было бы утомительно помещать каждую функцию, которую мы хотим передать \ops{map/2} в качестве параметра, в модуль, затем её экспортировать, компилировать и т.д. В сущности, это просто непрактично. Нам нужны функции, которые можно было бы определять на ходу\ldots
\section{Анонимные функции}
\label{anonymous_functions}
Анонимные функции, или \emph{funs}, справляются с этой проблемой, позволяя вам декларировать особенный вид функций без необходимости их именования. Такие функции могут делать практически всё, что умеют обычные функции, кроме рекурсивных вызовов (как бы они их делали? Они же анонимные!) Вот их синтаксис:
\begin{lstlisting}[style=erlang]
fun(Args1) ->
    Expression1, Exp2, ..., ExpN;
    (Args2) ->
    Expression1, Exp2, ..., ExpN;
    (Args3) ->
    Expression1, Exp2, ..., ExpN
end
\end{lstlisting}
А использовать их можно следующим способом:
\begin{lstlisting}[style=erlang]
7> Fn = fun() -> a end.
#Fun<erl_eval.20.67289768>
8> Fn().
a
9> hhfuns:map(fun(X) -> X + 1 end, L).
[2,3,4,5,6]
10> hhfuns:map(fun(X) -> X - 1 end, L).
[0,1,2,3,4]
\end{lstlisting}
Теперь\--то вам, должно быть, становится ясна одна из причин, по которой людям так нравится функциональное программирование: в коде можно создавать абстракции на очень низком уровне. Поэтому основные концепции, такие как циклы, можно игнорировать, и сконцентрироваться на том, \emph{что} необходимо сделать, вместо того \emph{как} это должно быть сделано.

Анонимные функции и так довольно хороши как абстракции, но в них заключены дополнительные скрытые силы:
\begin{lstlisting}[style=erlang]
11> PrepareAlarm = fun(Room) ->
11>                     io:format("Alarm set in ~s.~n",[Room]),
11>                     fun() -> io:format("Alarm tripped in ~s! Call Batman!~n",[Room]) end
11>                   end.
#Fun<erl_eval.20.67289768>
12> AlarmReady = PrepareAlarm("bathroom").
Alarm set in bathroom.
#Fun<erl_eval.6.13229925>
13> AlarmReady().
Alarm tripped in bathroom! Call Batman!
ok
\end{lstlisting}
\begin{wrapfigure}{r}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{batman.png}
\end{wrapfigure}
Бэтмэн, оставайся на связи! Что тут происходит? Во\--первых, мы декларируем анонимную функцию, которую присваиваем переменной \emph{PrepareAlarm}. Эта функция ещё не запускалась: её исполнят во время вызова \ops{PrepareAlarm(''bathroom'')}. В этот момент будет обработан вызов функции \ops{io:format/2}, и на экране отобразится текст ``Alarm set''. Второе выражение (ещё одна анонимная функция), возвращается вызывающему коду и присваивается переменной \emph{AlarmReady}. Обратите внимание, что в этой функции значение переменной \emph{Room} берётся из <<родительской>> функции (\emph{PrepareAlarm}). Этот эффект имеет отношение к концепции \emph{замыканий} (closures).

Чтобы понять замыкания, необходимо понять что такое область определения (контекст). Область определения функции можно представить как место, в котором хранятся все переменные и их значения. В функции \ops{base(A) -> B = A + 1.}, \emph{A} и \emph{B} определены в контексте функции \ops{base/1}. Это означает, что в любом месте функции \ops{base/1} можно обратиться к переменной \emph{A} или \emph{B}, и ожидать, что с ними связано значение. А когда я говорю ``в любом месте'' \--- я, сынок, не шучу; к анонимным функциям это тоже относится:
\begin{lstlisting}[style=erlang]
base(A) ->
    B = A + 1,
    F = fun() -> A * B end,
    F().
\end{lstlisting}

В этой версии нашей функции, переменная \emph{B} всё ещё равна \ops{A + 1}, а \emph{F} по прежнему исполняется без проблем. Но вот переменная \emph{C} существует лишь в контексте анонимной функции \emph{F}. Когда \ops{base/1} пытается в последней строке обратиться к значению \emph{C}, она натыкается на свободную переменную. По правде говоря, если бы вы попытались эту функцию скомпилировать, компилятор пришёл бы в бешенство. Наследование работает лишь в одну сторону.

Важно отметить, что наследуемый контекст повсюду сопровождает анонимную функцию, даже когда её передают другой функции:
\begin{lstlisting}[style=erlang]
a() ->
    Secret = "pony",
    fun() -> Secret end.
 
b(F) ->
    "a/0's password is "++F().
\end{lstlisting}

А если мы её скомпилируем:
\begin{lstlisting}[style=erlang]
14> c(hhfuns).
{ok, hhfuns}
15> hhfuns:b(hhfuns:a()).
"a/0's password is pony"
\end{lstlisting}

Кто разболтал пароль функции \ops{a/0}? Сама функция \ops{a/0} и разболтала. Так как анонимная функция в момент объявления находится в контексте \ops{a/0}, то она всё ещё будет иметь доступ к этому контексту во время её исполнения в функции \ops{b/1}, как я объяснял выше. Это свойство очень полезно, так как позволяет переносить параметры и их содержимое за пределы оригинального контекста, туда где в полном контексте больше нет необходимости (в точности так, как мы поступили с Бэтмэном в предыдущем примере).

Анонимные функции чаще всего используют для переноса состояния, когда ваша функция принимает несколько аргументов, но один из этих аргументов \--- константа:
\begin{lstlisting}[style=erlang]
16> math:pow(5,2).
25.0
17> Base = 2.
2
18> PowerOfTwo = fun(X) -> math:pow(Base,X) end.
#Fun<erl_eval.6.13229925>
17> hhfuns:map(PowerOfTwo, [1,2,3,4]).
[2.0,4.0,8.0,16.0]
\end{lstlisting}

Обернув вызов функции \ops{math:pow/2} анонимной функцией, в контексте которой переменная \emph{Base} получает своё значение, мы используем числа из списка как степени для \emph{Base} при каждом вызове функции \emph{PowerOfTwo}.

Если внутри анонимной функции попытаться переопределить контекст, можно столкнуться с проблемой:
\begin{lstlisting}[style=erlang]
base() ->
    A = 1,
    (fun() -> A = 2 end)().
\end{lstlisting}

Этот код объявит анонимную функцию, а затем исполнит её. Так как анонимная функция наследует контекст функции \ops{base/0}, то попытка использовать оператор \ops{=\strut} приведёт к сравнению числа 2 c переменной \emph{A} (которая связана со значением 1). Эта операция гарантированно закончится неудачей. Тем не менее, переменную всё же можно переопределить, если сделать это во вложенном заголовке функции:
\begin{lstlisting}[style=erlang]
base() ->
    A = 1,
    (fun(A) -> A = 2 end)(2).
\end{lstlisting}

Этот код сработает. При компиляции вы получите предупреждение о \emph{затенении} (shadowing) (``\emph{Warning: variable 'A' shadowed in 'fun'}''). Затенение \--- это термин, который используют для описания ситуации, когда новая переменная имеет имя, совпадающее с именем переменной из родительского контекста. Это предупреждение призвано предотвратить вероятные ошибки (и чаще всего ему это удаётся), поэтому в подобных обстоятельствах подумайте, а не переименовать ли вам одну из переменных.

Как я и обещал в конце предыдущей главы, давайте немного отвлечёмся от теории анонимных функций, и исследуем некоторые общие абстракции, которые позволяют нам избавиться от необходимости писать рекурсивные функции.
\section{Отображения (maps), фильтры, свёртки (folds) и прочее}
\label{maps_filters_folds_and_more}
\begin{wrapfigure}{r}{0.4\linewidth}
    \includegraphics[width=1\linewidth]{erland.png}
\end{wrapfigure}
В начале этой главы я кратко продемонстрировал, как преобразовать две подобные функции в функцию \ops{map/2}. Также я утверждал, что такую функцию можно использовать для любого списка, в котором мы хотим производить какое\--либо действие с каждым элементом. Функция выглядела следующим образом:
\begin{lstlisting}[style=erlang]
map(_, []) -> [];
map(F, [H|T]) -> [F(H)|map(F,T)].
\end{lstlisting}
Однако, существует много других абстракций, подобных этой, которые можно построить из часто встречающихся рекурсивных функций. Давайте для начала взглянем на парочку функций:
\begin{lstlisting}[style=erlang]
%% only keep even numbers
even(L) -> lists:reverse(even(L,[])).
 
even([], Acc) -> Acc;
even([H|T], Acc) when H rem 2 == 0 ->
    even(T, [H|Acc]);
even([_|T], Acc) ->
    even(T, Acc).
 
%% only keep men older than 60
old_men(L) -> lists:reverse(old_men(L,[])).
 
old_men([], Acc) -> Acc;
old_men([Person = {male, Age}|People], Acc) when Age > 60 ->
    old_men(People, [Person|Acc]);
old_men([_|People], Acc) ->
    old_men(People, Acc).
\end{lstlisting}

Первая принимает список чисел и возвращает только чётные. Вторая проходит по списку с данными вида \{Пол, Возраст\} и возвращает лишь записи о мужчинах старше 60 лет. В этих функциях найти общее немного сложнее, но некоторое подобие всё же есть. Обе функции работают над списками, возвращают элементы, которые прошли некий тест (его ещё называют \emph{предикатом}), а остальные элементы отбрасывают. Из этого обобщения мы можем извлечь всю необходимую нам информацию и преобразовать её в функцию:
\begin{lstlisting}[style=erlang]

filter(Pred, L) -> lists:reverse(filter(Pred, L,[])).
 
filter(_, [], Acc) -> Acc;
filter(Pred, [H|T], Acc) ->
    case Pred(H) of
        true  -> filter(Pred, T, [H|Acc]);
        false -> filter(Pred, T, Acc)
    end.
\end{lstlisting}

Чтобы воспользоваться функцией\--фильтром, нам необходимо лишь получить извне тестирующую функцию. Скомпилируйте модуль \ops{\href{http://learnyousomeerlang.com/static/erlang/hhfuns.erl}{hhfuns}} и попробуйте им воспользоваться:
\begin{lstlisting}[style=erlang]
1> c(hhfuns).
{ok, hhfuns}
2> Numbers = lists:seq(1,10).
[1,2,3,4,5,6,7,8,9,10]
3> hhfuns:filter(fun(X) -> X rem 2 == 0 end, Numbers).
[2,4,6,8,10]
4> People = [{male,45},{female,67},{male,66},{female,12},{unkown,174},{male,74}].
[{male,45},{female,67},{male,66},{female,12},{unkown,174},{male,74}]
5> hhfuns:filter(fun({Gender,Age}) -> Gender == male andalso Age > 60 end, People).
[{male,66},{male,74}]
\end{lstlisting}

Эти примеры демонстрируют, что программисту, который использует функцию \ops{filter/2}, нужно лишь задать предикат и указать список, который будет фильтроваться. О самом процессе перемещения по списку и об отбрасывании ненужных элементов думать больше не нужно. При обобщении функционального кода происходит одна важная вещь: мы пытаемся избавиться от того, что остаётся постоянным, и позволяем программисту предоставить лишь то, что подвергается изменению.

В предыдущей главе мы применяли к спискам другой вид рекурсивных манипуляций, в котором мы последовательно рассматривали каждый элемент списка и приводили их к одному ответу. Эта операция называется \emph{свёрткой} (fold) и может применяться для следующих функций:
\begin{lstlisting}[style=erlang]
%% find the maximum of a list
max([H|T]) -> max2(T, H).
 
max2([], Max) -> Max;
max2([H|T], Max) when H > Max -> max2(T, H);
max2([_|T], Max) -> max2(T, Max).
 
%% find the minimum of a list
min([H|T]) -> min2(T,H).
 
min2([], Min) -> Min;
min2([H|T], Min) when H < Min -> min2(T,H);
min2([_|T], Min) -> min2(T, Min).
 
%% sum of all the elements of a list
sum(L) -> sum(L,0).
 
sum([], Sum) -> Sum;
sum([H|T], Sum) -> sum(T, H+Sum).
\end{lstlisting}
\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{foldr.png}
\end{wrapfigure}

Чтобы понять как себя ведёт свёртка, нам необходимо найти общее в этих действиях, а после найти различия. Как было указано выше, мы всегда приводим список к единичному значению. Следовательно, наша свёртка должна повторять действие, сохраняя один элемент. Нам не нужно строить новый список. Стражи нам не понадобятся, так как они присутствуют не всегда, а поэтому должны находиться в пользовательской функции. В этом отношении наша функция свёртки будет, скорее всего, походить на функцию sum.

Ещё одной неприметной частью всех трёх функций, о которой мы пока не упоминали, является то, что у каждой функции должно быть начальное значение, от которого будет начинаться отсчёт. В случае \ops{sum/2} мы используем 0, так как проводим операцию сложения, которая нейтральна относительно 0, и при вычислении \ops{X = X + 0} мы никак не повлияем на результат. Если бы мы использовали операцию умножения \ops{X = X * 1}, то в качестве стартового значения избрали бы 1. У функций \ops{min/1} и \ops{max/1} стартового значения по умолчанию быть не может. Если список полностью состоит из отрицательных чисел, а мы начнём с 0, то получим неверный результат. Поэтому нам необходимо использовать в качестве начальной точки первый элемент списка. К сожалению, мы не можем заранее применить такие рассуждения к любой ситуации, а поэтому оставляем решение этой проблемы программисту. Принимая во внимание все перечисленные элементы, мы можем построить следующую абстракцию:
\begin{lstlisting}[style=erlang]
fold(_, Start, []) -> Start;
fold(F, Start, [H|T]) -> fold(F, F(H,Start), T).
\end{lstlisting}
А затем исполнить:
\begin{lstlisting}[style=erlang]
6> c(hhfuns).
{ok, hhfuns}
7> [H|T] = [1,7,3,5,9,0,2,3].   
[1,7,3,5,9,0,2,3]
8> hhfuns:fold(fun(A,B) when A > B -> A; (_,B) -> B end, H, T).
9
9> hhfuns:fold(fun(A,B) when A < B -> A; (_,B) -> B end, H, T).
0
10> hhfuns:fold(fun(A,B) -> A + B end, 0, lists:seq(1,6)).
21
\end{lstlisting}

Практически любую функцию, которая сводит список значений к одному элементу, можно выразить в виде свёртки.

Забавно то, что вы можете представить аккумулятор как единичный элемент (или единичную переменную), а аккумулятор может быть списком. Следовательно, мы можем использовать свёртку для построения списков. Это означает, что свёртка универсальна в том смысле, что с её помощью можно реализовать практически любую другую рекурсивную функцию для списков, даже отображение и фильтр:
\begin{lstlisting}[style=erlang]
reverse(L) ->
    fold(fun(X,Acc) -> [X|Acc] end, [], L).
 
map2(F,L) ->
    reverse(fold(fun(X,Acc) -> [F(X)|Acc] end, [], L)).
 
filter2(Pred, L) ->
    F = fun(X,Acc) ->
        case Pred(X) of
            true  -> [X|Acc];
            false -> Acc
        end
    end,
    reverse(fold(F, [], L)).
\end{lstlisting}

И эти функции будут работать так же как и те, что мы написали ранее. Ну как, мощные абстракции или нет?

Отображение, фильтры и свёртки \--- это лишь часть функций для списков, которые предоставляются стандартной библиотекой Erlang (см. \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#map/2}{lists:map/2}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#filter/2}{lists:filter/2}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#foldl/3}{lists:foldl/3}} и \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#foldr/3}{lists:foldr/3}}. Стоит отметить также функции \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#all/2}{all/2}} и \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#any/2}{any/2}}, которые принимают предикат и проверяют, что для каждого элемента предикат возвращает true, или что хотя бы для одного из них предикат возвращает true, соответственно. Ещё есть функция \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#dropwhile/2}{dropwhile/2}}, которая игнорирует элементы списка до тех пор, пока не находит один, удовлетворяющий предикату, и противоположная функция \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#takewhile/2}{takewhile/2}}, которая будет возвращать элементы до тех пор, пока не встретит один, для которого предикат не возвращает true. Две предыдущие функции объединяет \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#partition/2}{partition/2}}. Эта функция принимает один список, а возвращает два. Первый содержит термы, которые удовлетворяют предикату, а второй \--- остальные элементы. Кроме того, для обработки списков часто используются такие функции как \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#flatten/1}{flatten/1}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#flatlength/1}{flatlength/1}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#flatmap/2}{flatmap/2}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#merge/1}{merge/1}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#nth/2}{nth/2}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#nthtail/2}{nthtail/2}}, \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#split/2}{split/2}} и другие.

Также там можно найти другие функции, такие как zip\--функция (которую мы рассматривали в предыдущей главе), unzip\--функция, комбинации отображений и свёрток и т.д. Рекомендую вам прочитать \href{http://erldocs.com/R15B/stdlib/lists.html}{документацию, которая касается списков}. В ней вы найдёте примеры использования списковых функций. Применяя то, что умные люди заключили в этих абстракциях, у вас редко будет появляться необходимость в самостоятельном создании рекурсивных функций.
\end{document}
