\chapter{Снова о многопроцессорности}
\section{Предъявите ваше состояние}
\begin{wrapfigure}{r}{0.35\linewidth}
    \includegraphics[width=1\linewidth]{turkey.png}
\end{wrapfigure}
Примеры, показанные в предыдущей главе, годились для использования в качестве демонстрационного материала, но с таким ограниченным инструментарием далеко не уйдёшь.
Нет, примеры плохими не назовёшь, но от процессов и акторов пользы мало, когда они представлены только функциями и сообщениями.
Для устранения этого недостатка нам необходимо уметь сохранять в процессе состояние.

Давайте, для начала, создадим функцию в новом модуле \href{http://learnyousomeerlang.com/static/erlang/kitchen.erl}{kitchen.erl}, которая позволит процессу выполнять функции холодильника.
Процессу разрешено совершать две операции: хранить еду в холодильнике и вынимать её оттуда.
Вынимать можно только ту еду, которая была заранее помещена в холодильник.
Пусть основой нашего процесса будет следующая функция:
\begin{lstlisting}[style=erlang]
-module(kitchen).
-compile(export_all).
 
 fridge1() ->
     receive
         {From, {store, _Food}} ->
         From ! {self(), ok},
         fridge1();
     {From, {take, _Food}} ->
         %% uh....
         From ! {self(), not_found},
         fridge1();
     terminate ->
         ok
     end.
\end{lstlisting}

Что\--то здесь не так.
Когда мы делаем запрос на хранение еды, процесс возвращает результат \emph{ok}, но фактически еда нигде не сохраняется.
Будет вызвана функция \emph{fridge1()}, и она начнёт исполняться с чистого листа, без сохранённого состояния.
Очевидно также, что когда мы просим процесс извлечь еду из холодильника, её просто неоткуда взять, и остаётся просто вернуть в качестве результата \emph{not\_found}.
Ясно, что для хранения и извлечения провизии нам необходимо добавить в функцию состояние.

Благодаря рекурсии, состояние процесса может целиком содержаться в параметрах, которые передаются в функцию.
Для нашего процесса\--холодильника можно хранить весь провиант в виде списка, и когда кто\--нибудь захочет поесть, мы сможем поискать в нём необходимый продукт:
\begin{lstlisting}[style=erlang]
fridge2(FoodList) ->
    receive
        {From, {store, Food}} ->
            From ! {self(), ok},
            fridge2([Food|FoodList]);
        {From, {take, Food}} ->
            case lists:member(Food, FoodList) of
                true ->
                    From ! {self(), {ok, Food}},
                    fridge2(lists:delete(Food, FoodList));
                false ->
                    From ! {self(), not_found},
                    fridge2(FoodList)
            end;
        terminate ->
            ok
    end.
\end{lstlisting}

Сразу можно заметить, что \ops{fridge2/1} принимает один аргумент \--- \emph{FoodList}.
Когда мы пошлём сообщение вида \ops{\{From, \{store, Food\}\}} \--- функция добавит значение \emph{Food} в \emph{FoodList} перед следующей итерацией.
На следующей итерации рекурсивного вызова можно будет извлечь из списка тот же самый элемент, который мы туда поместили ранее.
Я даже реализовал эту возможность.
Функция использует \ops{lists:member/2} для проверки наличия \ops{Food} в \ops{FoodList}.
В зависимости от результата, полученный элемент либо пересылается вызывающему процессу (и удаляется из \emph{FoodList}), либо получателю отсылается атом \emph{not\_found}:
\begin{lstlisting}[style=erlang]
1> c(kitchen).
{ok,kitchen}
2> Pid = spawn(kitchen, fridge2, [[baking_soda]]).
<0.51.0>
3> Pid ! {self(), {store, milk}}.
{<0.33.0>,{store,milk}}
4> flush().
Shell got {<0.51.0>,ok}
ok
\end{lstlisting}

Функция хранения продуктов в холодильнике вроде бы работает.
Теперь попробуем поместить туда различные продукты, а затем их извлечь.
\begin{lstlisting}[style=erlang]
5> Pid ! {self(), {store, bacon}}.
{<0.33.0>,{store,bacon}}
6> Pid ! {self(), {take, bacon}}.
{<0.33.0>,{take,bacon}}
7> Pid ! {self(), {take, turkey}}.
{<0.33.0>,{take,turkey}}
8> flush().
Shell got {<0.51.0>,ok}
Shell got {<0.51.0>,{ok,bacon}}
Shell got {<0.51.0>,not_found}
ok
\end{lstlisting}

В соответствии с нашими ожиданиями, мы можем достать из холодильника бекон, потому что мы его туда поместили первым по счёту (вместе с молоком и пищевой содой), но когда мы просим процесс\--холодильник достать немного мяса индейки, у него ничего не выходит.
Именно поэтому мы получаем последнее сообщение \ops{\{<0.51.0>,not\_found\}}.
