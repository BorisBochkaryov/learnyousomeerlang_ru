\chapter{Начинаем}
\label{starting-out}
\section{Оболочка}
\label{the-shell}
В Erlang можно проверить большую часть кода в эмуляторе.
В нём можно запускать компилированные скрипты, но также можно редактировать код вживую.
Чтобы запустить оболочку в Linux, откройте терминал и наберите \ops{\$ erl}.
Если вы всё правильно настроили, появится текст похожий на этот: 
\begin{lstlisting}[style=repl]
Erlang R13B01 (erts-5.7.2) [source] [smp:2:2] 
[rq:2] [async-threads:0] [hipe] [kernel-poll:false] 
 
Eshell V5.7.2  (abort with ^G) 
\end{lstlisting}

Поздравляю, вы запустили оболочку Erlang! 

Пользователи Windows тоже могут запустить \ops{erl.exe}, но лучше использовать \ops{werl.exe}, который можно найти в стартовом меню (\ops{programs > Erlang}).
Werl это оболочка Erlang, которая создана специально для Windows.
Она поддерживает оформление окон с полосами прокрутки и операциями редактирования (такими, например, как копирование\--вставка, которых очень не хватает в стандартной оболочке \ops{cmd.exe} для Windows).
Правда, если вы захотите использовать перенаправление стандартного ввода\--вывода или каналы, то erl вам всё\--таки пригодится. 

В оболочке мы сможем вводить и запускать код, но сначала посмотрим как с ней обращаться.
\section{Команды оболочки}
\label{shell-commands}
В оболочку Erlang встроено подмножество функций популярного текстового редактора Emacs, использование которого берёт начало в 70\--х годах.
Если вы знакомы с Emacs, то ваших знаний будет достаточно.
У всех остальных и без этих знаний всё получится.

\begin{wrapfigure}{r}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{shell.png}
\end{wrapfigure}
К примеру, если напечатать какой\--либо текст и нажать \ops{\textasciicircum A}(Ctrl+A), ваш курсор переместится в начало строки.
\ops{\textasciicircum E}(Ctrl+E) переносит курсор в конец строки.
Чтобы перемещаться вперёд и назад, используйте клавиши со стрелками <<влево>> и <<вправо>>.
Клавиши <<вверх>> и <<вниз>> воспроизводят предыдущие или последующие строки, которые уже вводились ранее. Это позволяет не набирать их повторно.

Если написать, к примеру, \ops{li} и нажать <<tab>>, оболочка дополнит за вас слово до \ops{lists:}.
Если нажать tab ещё раз, то оболочка предложит функции, которые могут следовать за lists:.
Так Erlang дополняет имя модуля lists и предлагает функции, которые тот содержит.
Способ записи может показаться странным, но не переживайте, вы к нему быстро привыкнете.
Думаю, мы достаточно ознакомились с функциональностью оболочки, чтобы понимать что к чему.
Кроме одного момента: мы не знаем как из неё выйти!
Ответ на этот вопрос получить очень просто.
Напишите \ops{help().} и вы получите описание команд, которые можно использовать в оболочке (не забудьте написать точку (\ops{\strut.}), она нужна для исполнения команды).
Некоторыми из них мы воспользуемся чуть позже, но сейчас для выхода из оболочки нам нужна единственная строка:\\ 
\ops{q() -- quit - shorthand for init:stop()} 

Это один из способов выхода (если быть точным, то два способа).
Но от этой команды мало толку, если оболочка зависла!
Те из вас, кто внимательно следил за выводом оболочки при запуске, видели комментарий о том, что можно <<прекратить исполнение при помощи \ops{\textasciicircum G}>>.
Нажмём это сочетание клавиш и напечатаем h, чтобы получить подсказку.
\begin{lstlisting}[style=repl]
User switch command
--> h
c [nn]            - connect to job
i [nn]            - interrupt job
k [nn]            - kill job
j                 - list all jobs
s [shell]         - start local shell
r [node [shell]]  - start remote shell
q        - quit erlang
? | h             - this message
-->
\end{lstlisting}

Если нажать \ops{i} и следом \ops{c}, то Erlang остановит исполнение кода и возвратится в интерактивную оболочку.
По нажатию \ops{j} будет выведен список запущенных процессов (звёздочка следом за номером указывает, что задача исполняется в данный момент).
Процесс можно прервать, написав \ops{i} и следом номер задачи.
Команда \ops{k} не прерывает оболочку, а полностью завершает её исполнение.
Команда \ops{s} запускает новую оболочку.
\begin{lstlisting}[style=repl]
Eshell V5.7.2  (abort with ^G)
1> "OH NO THIS SHELL IS UNRESPONSIVE!!! *hits ctrl+G*"
User switch command
--> k
--> c
Unknown job
--> s
--> j
2* {shell,start,[]}
--> c 2
Eshell V5.7.2  (abort with ^G)
1> "YESS!"
\end{lstlisting}

Если вы полностью прочитали текст подсказки, то, возможно, заметили, что мы можем запустить удалённую оболочку.
Не буду сейчас вдаваться в детали, но этот факт даёт представление о том, на что ещё способна виртуальная машина Erlang, кроме запуска кода.
А теперь начнём (на этот раз по\--настоящему).
