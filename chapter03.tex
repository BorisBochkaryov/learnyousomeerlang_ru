\chapter{Начинаем (по\--настоящему)}
\label{starting-out-for-real}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
    Erlang довольно простой и компактный язык (в том же смысле, в котором C проще чем C++).
    В языке определены несколько фундаментальных типов данных.
    В этой главе мы рассмотрим их большую часть.
    Рекомендуется обязательно прочитать главу, так как в ней объясняются элементы необходимые для построения всех программ, которые вы позже будете писать на Erlang.
    \end{minipage}
}
\section{Числа}
В оболочке Erlang выражения должны завершаться точкой, за которой следует пробел (возврат каретки, пробел и т.д.), иначе это выражение не будет выполнено.
Можно разделять выражения запятыми, но лишь результат последнего выражения отобразится на экране (однако, все остальные выражения будут всё равно исполнены).
Для большинства людей этот синтаксис покажется довольно непривычным.
Он восходит к тем временам, когда Erlang был реализован на Prolog \--- языке логического программирования.

Откройте оболочку Erlang так, как мы это делали в предыдущей главе, и давайте\--ка что\--нибудь попечатаем!
\begin{lstlisting}[style=repl]
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472.
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
\end{lstlisting}

Возможно вы заметили, что для Erlang не имеет значения, вводите вы дробные числа или целые: в арифметических операциях поддерживаются оба типа.
Целые и дробные значения это, в общем\--то, единственные типы данных, которые будут прозрачно обрабатываться математическими операторами Erlang.
Однако, если вы хотите делить целое на целое \--- используйте \ops{div}, а для операции взятия остатка по модулю используйте оператор \ops{rem}(remainder, остаток).

Обратите внимание, что мы можем использовать несколько операторов в одном выражении, и порядок вычисления арифметических операций подчиняется обычным правилам.
\begin{lstlisting}[style=repl]
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
\end{lstlisting}

Если хотите выразить целое число в системе счисления с основанием отличным от 10, то просто введите его в виде \ops{Основание\#Число} (основание может меняться в диапазоне 2\ldots36):
\begin{lstlisting}[style=repl]
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
\end{lstlisting}

Прекрасно!
Erlang обладает возможностями калькулятора, который пылится где\--то в дальнем углу вашего стола.
Вдобавок, у калькулятора весьма странный синтаксис!
Просто великолепно!
\section{Неизменные переменные}\label{invariable-variables}
Арифметические вычисления это отлично, но без возможности сохранять промежуточные результаты далеко не уедешь.
Для этого мы будем использовать переменные.
Если вы прочитали введение к этой книге, то знаете, что переменные в функциональном программировании не могут меняться.
Общее поведение переменных можно продемонстрировать в следующих 7 выражениях (обратите внимание, что имена переменных начинаются с заглавной буквы):
\begin{lstlisting}[style=repl]
1> One.
* 1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
\end{lstlisting}

Первое, что можно заметить: значение можно присваивать переменной ровно один раз, после этого можно <<притвориться>>, что вы присваиваете значение, только если это то же самое значение, которое ей уже присвоено.
Erlang\--у не понравится, если они будут различны.
Объяснение кроется в свойствах оператора \ops{\strut=}.
Оператор \ops{\strut=} (не переменные) выполняет функцию сравнения значений и сообщает, если они отличаются.
Если они одинаковы, то оператор просто возвращает значение:
\begin{lstlisting}[style=repl]
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
\end{lstlisting}

Оператор в сочетании с переменными делает следующее: если выражение слева \--- свободная переменная (с ней не связано значение), Erlang автоматически свяжет значение, которое находится справа, с переменной слева.
После этого сравнение завершится успешно, и значение переменной сохранится в памяти.

Такое поведение оператора \ops{\strut=} это основа <<сопоставления с образцом>> (pattern matching), которое существует во многих функциональных языках программирования, хотя его реализация в Erlang обычно считается более гибкой и полной в сравнении с аналогами.
Мы рассмотрим сопоставление с образцом более детально, когда будем разбираться с кортежами и списковыми типами, чуть позже в этой же главе, а также в связи с функциями в последующих главах.

Ещё один факт, который можно почерпнуть из команд 1\--7 это то, что имена переменных должны начинаться с заглавной буквы.
Команда 7 завершилась ошибкой, потому что слово \emph{two} начинается со строчной буквы.
Имена переменных технически могут начинатся со знака подчёркивания ('\_'), но по соглашению такие имена используются только для переменных, значение которых вас не интересует, но вы всё\--таки посчитали, что было бы неплохо описать, что же в них содержится.

Ещё можно завести переменную, имя которой будет состоять просто из знака подчёркивания:
\begin{lstlisting}[style=repl]
10> _ = 14+3.
17
11> _.
* 1: variable '_' is unbound
\end{lstlisting}

В отличие от любой другой переменной, у этой никогда не будет собственного значения.
На данный момент это для нас абсолютно бесполезно, но запомним, что такая переменная существует.
Она нам ещё пригодится.\\ 
\colorbox{lgray}
{
\begin{minipage}{1.0\linewidth}
\textbf{Замечание:} если вы экспериментируете в оболочке и присвоили переменной неверное значение, то можно <<удалить>> эту переменную при помощи функции \ops{f(Variable).}.
Чтобы очистить все переменные, используйте \ops{f().}.
\par 
Эти функции работают только в оболочке и созданы специально, чтобы помогать вам во время тестирования.
В настоящих программах мы не сможем удалять значения таким способом.
Смысл этого поведения становится понятен, если представить Erlang в производственном окружении: вполне возможно, что оболочка будет непрерывно запущена на протяжении нескольких лет\ldots Готов поспорить, что переменная X будет использована за это время больше одного раза.
\end{minipage}
}
\section{Атомы}\label{atoms}
Атомы являются причиной, по которой имена переменных должны начинаться с заглавной буквы.
Атомы это литералы \--- константы с собственным именем для некоторого значения.
Атомы это только то, что вы видите и больше ничего в них нет.
Атом \emph{cat} просто означает <<cat>> и ничего больше.
С ним нельзя поиграть, его нельзя изменить, его нельзя разбить вдребезги; это \emph{cat}.
Cмиритесь с этим.

Кроме записи атомов в виде слов, которые начинаются со строчной буквы, существует ещё несколько способов записи:
\begin{lstlisting}[style=repl]
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom
\end{lstlisting}

Если атом не начинается со строчной буквы или содержит символы отличные от букв и цифр, знака подчёркивания (\_) или @, то он должен обрамляться одиночными кавычками (').
Выражение под номером 5 также показывает, что атом, заключённый в одиночные кавычки, это совершенно то же самое, что и атом без них.

\begin{wrapfigure}{l}{0.3\linewidth}
    \includegraphics[width=1\linewidth]{atom.png}
\end{wrapfigure}
Я сравнил атомы с константами, у которых значением является их собственное имя.
Возможно, вы раньше работали с кодом, в котором использовались константы.
Пусть, к примеру, у меня есть значения, которые соответствуют цвету глаз: \ops{BLUE -> 1, BROWN -> 2,} \ops{GREEN -> 3, OTHER -> 4}.
Необходимо сопоставить имя константы с некоторым значением.
Атомы позволяют без этого обойтись.
Цвет глаз может просто быть 'blue', 'brown', 'green' и 'other'.
Эти цвета можно использовать в коде где угодно: значения никогда не будут пересекаться, и, вдобавок, такая константа всегда инициализирована.
Если вам и в самом деле нужны именно константы со связанными значениями, то всё\--таки существует способ их заполучить.
Мы рассмотрим его в главе~\ref{modules}.

Таким образом, атом хорош для представления данных, которые с ним связаны.
Сложновато без данных найти ему достойное применение.
Довольно об атомах.
Их время настанет, когда мы сможем компоновать их с другими типами данных.\\ 
\colorbox{lorange}
{
    \begin{minipage}{1.0\linewidth}
\textbf{Не забывайтесь:}

Атомы прекрасно подходят для отсылки сообщений и представления констант.
Но во многих случаях использование атомов скрывает подвох.
Обращение к атому происходит через <<таблицу атомов>>, которая занимает память (4 байт/атом в 32\--битной системе, 8 байт/атом в 64\--битной системе).
Таблица атомов не обрабатывается сборщиком мусора, поэтому атомы будут накапливаться до тех пор, пока система не остановится из\--за нехватки памяти, либо потому что было определено максимальное количество атомов \--- 1048577.

Поэтому атомы нельзя генерировать динамически ни в коем случае.
Если вам нужна надёжная система, но данные, введённые пользователем, роняют её из\--за конвертации ввода в атомы, то у вас серьёзные проблемы.
Атомы необходимо рассматривать только как инструменты разработчика, потому что на самом деле они как раз ими и являются.
\end{minipage}
}
\colorbox{lgray}{
    \begin{minipage}{1.0\linewidth}
    \textbf{Замечание:} некоторые атомы являются зарезервированными словами и их нужно использовать так, как было задумано разработчиками языка: для обозначения имён функций, операторов, выражений и т.д.
    Вот эти атомы: \ops{after and andalso band begin}
\ops{bnot bor bsl bsr bxor case catch}
\ops{cond div end fun if let not of}
\ops{or orelse query receive rem try when xor}
\end{minipage}
}
\section{Булева алгебра и операторы сравнения}\label{boolandcompare}
\begin{wrapfigure}[7]{r}{0.20\linewidth}
    \includegraphics[width=1.0\linewidth]{boole.png}
\end{wrapfigure}
Если бы человек не мог отличать большое от малого, истину от лжи, то ему бы пришлось нелегко.
В Erlang, как и в любом другом языке, есть возможность применения булевых операций и сравнения элементов.
Булева алгебра очень проста:\\ 
\begin{lstlisting}[style=repl]
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
\end{lstlisting} 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Замечание:} Операторы \ops{and} и \ops{or} всегда вычисляют аргументы, находящиеся по обе стороны от оператора.
        Если вам нужны операторы, которые вычисляют правую сторону только при необходимости, используйте \ops{andalso} и \ops{orelse}.
    \end{minipage}
} 

Проверка на равенство и неравенство тоже выполняется очень просто, но при этом используют несколько другие символы, чем те, которые можно увидеть во многих других языках:
\begin{lstlisting}[style=repl]
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
\end{lstlisting}

Во\--первых, если в привычном языке для проверки на равенство и неравенство используется \ops{==} и \ops{!=}, то в Erlang используется \ops{=:=} и \ops{=/=}.
Три последних выражения (строки с 9 по 11) также знакомят нас с ловушкой: Erlang не делает различий при выполнении арифметических действий между целыми числами и числами с плавающей запятой, но он будет различать эти числа при сравнении.
Впрочем, беспокоиться не о чем, потому что в этом случае придут на помощь операторы \ops{==} и \ops{/=}.
Помните об этом различии на случай, если понадобится сравнить числа, не сравнивая их типы.

Остальные операторы сравнения: \ops{$<$} (меньше чем), \ops{$>$} (больше чем), \ops{$>=$} (больше либо равно) и \ops{$=<$} (меньше либо равно).
Мне кажется, что последний оператор записывается задом\--наперёд, и из\--за него в моём коде появляется много синтаксических ошибок.
Будьте внимательны с этим \ops{$=<$}.
\begin{lstlisting}[style=repl]
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
\end{lstlisting}

Как узнать что происходит, если выполнить \ops{5 + llama} или \ops{5 == true}?
Нет способа лучше, чем исполнить эти выражения и испугаться сообщений об ошибках!
\begin{lstlisting}[style=repl]
12> 5 + llama.
** exception error: bad argument in an arithmetic expression
    in operator  +/2
        called as 5 + llama
\end{lstlisting}

Ну, что сказать?
Erlang не нравится, что вы неправильно используете его базовые типы!
Здесь эмулятор возвращает вполне понятное сообщение об ошибке.
Он сообщает, что ему не по нраву один из аргументов, которые окружают оператор \ops{+}!

Впрочем, Erlang сердится из\--за неверных типов не всегда по делу:
\begin{lstlisting}[style=repl]
13> 5 =:= true.
false
\end{lstlisting}

Почему для некоторых операторов различия в типах не существено, а для других имеет значение?
Хотя Erlang не разрешает суммировать что попало с чем угодно, он позволяет \emph{сравнивать}.
Так вышло потому, что создатели Erlang поставили прагматизм выше теории и решили, что было бы неплохо иметь возможность писать, к примеру, общие алгоритмы сортировки, которые могли бы упорядочивать любые элементы.
В большинстве случаев это упрощает жизнь.

Когда работаете с булевой алгеброй и сравнениями, стоит помнить ещё об одной вещи:
\begin{lstlisting}[style=repl]
14> 0 == false.
false
15> 1 < false.
true
\end{lstlisting}

Если вы раньше имели дело преимущественно с процедурными или объектно\--ориентированными языками, то, вероятно, сейчас рвёте волосы на голове.
Строка 14 должна возвращать \emph{true}, а строка 15 \emph{false}!
Везде false означает 0, а true \--- всё остальное!
Но не в Erlang.
Потому что я вам солгал.
Да, я вам наврал.
Стыд мне и срам.

В Erlang нет такого понятия как булевы значения \emph{true} и \emph{false}.
Элементы true и false на самом деле являются атомами, но они хорошо интегрированы в язык, и проблем с ними не будет, пока вы считаете, что false и true не значит ничего кроме false и true.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
    \textbf{Замечание:} при сравнении элементы выстроены в следующем порядке:\\ 
    \ops{number < atom < reference < fun < port < pid < tuple < list < bit string} 
    
    Все эти понятия вам пока неизвестны, но вы будете с ними знакомиться по мере продвижения по тексту книги.
    Просто помните, что именно благодаря им вы можете сравнивать что угодно с чем угодно!
    Процитирую Joe Armstrong, одного из создателей Erlang: <<Важен не сам порядок, а то, что этот порядок чётко определён.>>
    \end{minipage}
}
\section{Кортежи}
Кортеж \--- это способ организации данных.
С его помощью можно сгруппировать элементы, когда вам известно их количество.
Кортежи в Erlang записываются следующим образом: \ops{\{Element1, Element2,\ldots, ElementN\}}.
Как пример можно привести координаты (x, y), которые задают точку на плоскости.
Мы можем представить координаты как кортеж двух элементов:
\begin{lstlisting}[style=repl]
1> X = 10, Y = 4.
4
2> Point = {X,Y}.
{10,4}
\end{lstlisting}

В этом случае точка будет всегда представлена двумя значениями.
Вместо того, чтобы повсюду таскать за собой переменные X и Y, можно определить всего одну.
Но что же делать, если у меня есть переменная\--точка, а мне необходима лишь её X координата?
Эту информацию можно легко получить.
Помните, когда мы присваивали значения переменным, Erlang никогда не предъявлял претензии, если присваиваемые значения были равны содержимому переменных.
Давайте это используем!
Возможно, вам понадобится очистить уже определённые переменные командой \ops{f()}.
\begin{lstlisting}[style=repl]
3> Point = {4,5}.
{4,5}
4> {X,Y} = Point.
{4,5}
5> X.
4
6> {X,_} = Point.
{4,5}
\end{lstlisting}
\begin{wrapfigure}{l}{0.3\textwidth}
    \includegraphics[width=1.0\linewidth]{mr-brackets.png}
\end{wrapfigure}

Теперь мы можем использовать \emph{X}, чтобы получать первое значение в кортеже!
Как так получилось?
Сначала \emph{X} и \emph{Y} не имели значения, и поэтому считались свободными переменными.
Когда мы поместили их в кортеж \emph{\{X, Y\}} по левую сторону оператора \ops{=}, оператор \ops{=} сравнивает оба значения: \emph{\{X, Y\}} и \emph{\{4, 5\}}.
У Erlang хватает сообразительности, чтобы распаковать значения в кортеже и распределить их по свободным переменным слева от оператора присваивания.
После этого сравнение приходит к виду \ops{\{4, 5\} = \{4, 5\}}, и, очевидно, завершается успехом!
Это одна из многих форм операции сопоставления с образцом (pattern matching).

Заметьте, что в шестом выражении я использовал анонимную переменную \_.
Она должна использоваться именно в таких случаях: когда необходимо отбросить значение, которое нам не понадобится.
Переменная \_ всегда определена как свободная и служит элементом подстановки (wildcard) для сопоставления с образцом.
Для распаковки кортежей сопоставление с образцом будет работать лишь в том случае, когда количество элементов (длина кортежа) с обеих сторон одинаковое.
\begin{lstlisting}[style=repl]
7> {_,_} = {4,5}.
{4,5}
8> {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}
\end{lstlisting}

Также кортежи полезны при работы с одиночными значениями.
В каком смысле?
Простейший пример, температура:
\begin{lstlisting}[style=repl]
9> Temperature = 23.213.
23.213
\end{lstlisting}

В такой денёк неплохо было бы пойти на пляж\ldots Погодите\--ка, это температура по шкале Кельвина, Цельсия или Фаренгейта?
\begin{lstlisting}[style=repl]
10> PreciseTemperature = {celsius, 23.213}.
{celsius,23.213}
11> {kelvin, T} = PreciseTemperature.
** exception error: no match of right hand side value {celsius,23.213}
\end{lstlisting}

Операция вызывает ошибку, но это как раз то, чего мы хотим! Мы снова наблюдаем в работе сопоставление с образцом.
Оператор \ops{=} сравнивает \emph{\{kelvin, T\}} и \emph{\{celsius, 23.213\}}.
Не смотря на то, что переменная T свободна, Erlang при сравнении не посчитает атом \emph{celsius} идентичным атому \emph{kelvin}.
Будет брошено исключение, которое остановит выполнение кода.
Благодаря этому та часть нашей программы, которая ожидает температуру по шкале Кельвина, не сможет обработать температуру, которая будет представлена в градусах Цельсия.
Это помогает программисту знать, какие данные передаются, и помогает отлаживать код.
Кортеж, который содержит атом и следом за ним одиночный элемент, называется <<меченым кортежем>>.
Любой элемент кортежа может быть любого типа.
Он может быть даже ещё одним кортежем:
\begin{lstlisting}[style=repl]
12> {point, {X,Y}}.
{point,{4,5}}
\end{lstlisting}

Что же делать, если нам нужно работать с несколькими точками?
\section{Списки!}\label{lists}
Списки \--- это основа многих функциональных языков.
Их используют для решения различных проблем, и они, несомненно, являются наиболее используемой структурой данных в Erlang.
Списки могут содержать всё что угодно!
Числа, атомы, кортежи, другие списки \--- ваши самые дикие мечты в одной структуре.
Основной способ записи для списков: \ops{[Element1, Element2,\ldots,ElementN]}, и в них можно смешивать несколько разных типов данных:
\begin{lstlisting}[style=repl]
1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
\end{lstlisting}

Всё просто, не так ли?
\begin{lstlisting}[style=repl]
2> [97, 98, 99].
"abc"
\end{lstlisting}

Ой\--ой!
Это одна из самых нелюбимых вещей в Erlang: строки!
Строки \--- это тоже списки, поэтому записываются они абсолютно так же!
Почему люди их не любят?
А вот почему:
\begin{lstlisting}[style=repl]
3> [97,98,99,4,5,6].
[97,98,99,4,5,6]
4> [233].
"é"
\end{lstlisting}

Erlang напечатает список чисел в виде чисел, только если хотя бы одно из них нельзя представить в виде буквы!
Настоящих строк В Erlang просто нет!
Вне всякого сомнения этот факт будет вас преследовать, и из\--за него вы возненавидите язык.
Но не отчаивайтесь \--- есть и другие способы записи строк, с которыми мы познакомимся чуть позже в этой главе.\\ 
\colorbox{lorange}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Не забывайтесь:}\\ 
        Возможно, вы слышали, что Erlang плохо подходит для манипуляций со строками, потому что в нём нет встроенных строк, в отличие от большинства других языков.
        Произошло это потому, что Erlang был создан и использовался в телекоммуникационных компаниях.
        Они никогда (или редко) не использовали строки, и поэтому им никогда не приходило в голову официально добавить их в язык.
        Тем не менее, недостатки Erlang в области строковых преобразований со временем устраняются.
        Виртуальная машина имеет встроенную поддержку Unicode\--строк, и в целом операции со строками постоянно ускоряются.
        
        Строки также можно хранить в виде двоичной структуры данных, что увеличивает эффективность хранения и скорость обработки.
        Но всё же стандартной библиотеке не хватает некоторых функций.
        И, хотя в Erlang совершенно точно можно работать со строками, но для задач, в которых нужно делать много строковых преобразований, лучше подходят другие языки, например Perl или Python.
    \end{minipage}
}

Для склейки списков используют оператор\ops{++}.
Противоположное действие выполняет оператор \ops{$--$}, который удаляет элементы из списка:
\begin{lstlisting}[style=repl]
5> [1,2,3] ++ [4,5].
[1,2,3,4,5]
6> [1,2,3,4,5] -- [1,2,3].
[4,5]
7> [2,4,2] -- [2,4].
[2]
8> [2,4,2] -- [2,4,2].
[]
\end{lstlisting}

Оба оператора, \ops{++} и \ops{$--$} \--- ассоциативны справа.
Это означает, что элементы нескольких последовательных операций \ops{++} и \ops{$--$} будут обрабатываться справа налево как в следующем примере:
\begin{lstlisting}[style=repl]
9> [1,2,3] -- [1,2] -- [3].
[3]
10> [1,2,3] -- [1,2] -- [2].
[2,3]
\end{lstlisting}

Продолжим.
Первый элемент списка называется Головой (головным элементом), остальные элементы списка называются Хвостом (хвостовыми элементами).
Для их получения будем использовать две встроенные функции:
\begin{lstlisting}[style=repl]
11> hd([1,2,3,4]).
1
12> tl([1,2,3,4]).
[2,3,4]
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \textbf{Замечание:} встроенными обычно называют функции (ВФ), которые невозможно реализовать на чистом Erlang, поэтому они реализованы на С или любом другом языке, на котором реализован Erlang (в 80\--х это был Prolog).
        Есть также и ВФ, которые можно реализовать на Erlang, но их всё равно пишут на С, для увеличения скорости исполнения часто используемых операций.
        Как пример можно привести функцию \ops{length(List)}, которая (как вы, наверное, догадались) возвращает длину списка, который был передан ей в качестве аргумента.
    \end{minipage}
}

Операция доступа к головному элементу или добавления к голове списка выполняется быстро и эффективно.
Практически во всех случаях, в которых вы сталкиваетесь со списками, вам нужно выполнять операции с заголовком списка.
Из\--за того, что эта операция используется так часто, существует более простой метод отделения заголовка от хвоста, при помощи сопоставления с образцом: \ops{[Head|Tail]}.
Вот так можно добавить новый элемент в голову списка:
\begin{lstlisting}[style=repl]
13> List = [2,3,4].
[2,3,4]
14> NewList = [1|List].
[1,2,3,4]
\end{lstlisting}

При обработке списка неплохо было бы иметь быстрый способ хранить хвост, чтобы позже иметь возможность его обрабатывать.
Если вы помните как работают кортежи, и как мы использовали сопоставление с образцом для распаковки значений в точку (\emph{\{X, Y\}}), то вы знаете, что мы можем очень похожим методом извлечь первый элемент (заголовок).
\begin{lstlisting}[style=repl]
15> [Head|Tail] = NewList.
[1,2,3,4]
16> Head.
1
17> Tail.
[2,3,4]
18> [NewHead|NewTail] = Tail.
[2,3,4]
19> NewHead.
2
\end{lstlisting}

Оператор \ops{|} называется cons\--оператором (конструктором).
Любой список можно построить при помощи cons\--оператора и значений:
\begin{lstlisting}[style=repl]
20> [1 | []].
[1]
21> [2 | [1 | []]].
[2,1]
22> [3 | [2 | [1 | []] ] ].
[3,2,1]
\end{lstlisting}

Таким образом, любой список можно построить по следующей формуле: \ops{[Term1| [Term2 | [\ldots | [TermN]]]]\ldots}.
Следовательно, списки можно определить рекурсивно как заголовок, за которым следует хвост, который, в свою очередь является заголовком, за которым следуют другие заголовки.
В этом смысле можно представить список в виде земляного червя: можно разрубить его пополам, и вот у вас уже два червя.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{worm.png}
\end{figure} 

Способ, при помощи которого строятся списки в Erlang, иногда немного озадачивает людей, которые не имели дело с подобными конструкторами.
Чтобы немного привыкнуть к этой записи, попробуйте прочитать следующие примеры (подсказка: все они равнозначны друг другу):\\ 
\begin{lstlisting}[style=repl]
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
\end{lstlisting}

Если вам понятна эта концепция, то будут понятны и списочные выражения.\\ 
\colorbox{lgray}
{
    \begin{minipage}{1.0\linewidth}
        \emph{Замечание:} при использовании формы \ops{[1 | 2]} мы получаем так называемый <<неправильный список>>.
        Неправильные списки будут работать в сопоставлении с образцом вида \ops{[Head|Tail]}, но с ними не будут работать стандартные функции Erlang (даже \ops{length()}).
        В этих операциях Erlang ожидает правильные списки.
        У правильных списков последним элементом стоит пустой список.
        Когда мы объявляем список способом \ops{[2]}, то автоматически формируется правильный список.
        Поэтому запись \ops{[1|[2]]} сработает!
        Хотя неправильные списки синтаксически верны, их редко используют где\--то ещё, кроме пользовательских структур данных.
    \end{minipage}
}
\section{Списочные выражения}
Списочные выражения \--- это способ формировать или менять списки.
Программы, в которых используются списочные выражения, намного короче и проще для понимания.
Этот способ основан на идее записи математических множеств; если вы когда\--либо занимались теорией множеств, или сталкивались с математической записью, то наверняка знаете как это работает.
Мы задаём множество через определение свойств, которым должны удовлетворять его элементы.
Сначала списочные выражения могут показаться немного сложными, но усилия, потраченные на их понимание, стоят того.
С их помощью код становится чище и короче, поэтому вводите примеры и пытайтесь их понять!

Приведём пример математической записи множества: $\{x \in 
\mathbb{R}: x = x^2\}$.
Эта запись говорит о том, что вы хотите получить действительные числа, которые равны собственному квадрату.
Результатом будет множество $\{0, 1\}$.
В качестве примера более простой записи можно привести \ops{\{x : x $>$ 0\}}.
В результате мы должны получить все числа больше 0.

Списочные выражения в Erlang можно представить как построение множеств из других множеств.
Пусть нам дано множество \ops{\{2n : n in L\}}, где L это список $[1, 2, 3, 4]$.
В Erlang это можно записать как:\\ 
\begin{lstlisting}[style=repl]
1> [2*N || N <- [1,2,3,4]].
[2,4,6,8]
\end{lstlisting}

Если сравнить математическую запись с записью в Erlang, то можно заметить, что они не так уж сильно различаются: фигурные скобки (\{\}) становятся квадратными ([]), двоеточие (:) становится двумя вертикальными чертами (||), а слово <<in>> переходит в символ стрелки ($<-$).
Мы просто заменяем символы, но логика остаётся прежней.
В примере, приведённом выше, каждое значение $[1, 2, 3, 4]$ последовательно помещается в N (проводится операция сопоставления с образцом для каждого значения в списке).
Стрелка выполняет ту же функцию, что и оператор\ops{=}, с тем лишь отличием, что она не бросает исключения.

Также в списочные выражения можно добавлять ограничивающие условия, используя операции, которые возвращают булевы значения.
Если нам понадобились чётные числа от единицы до десяти, мы можем записать что\--то вроде:
\begin{lstlisting}[style=repl]
2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
\end{lstlisting}

Где конструкция \ops{X rem 2 =:= 0} проверяет число на чётность.
Практическая польза этого подхода становится ясна, когда нам нужно применить функцию к каждому элементу списка или наложить на элементы какие\--либо ограничения и т.д.
К примеру, мы владеем рестораном.
Входит посетитель, видит наше меню и спрашивает, может ли он получить цены всех блюд, которые стоят от \$3 до \$10, включая налоги (скажем, 7\%), и налог должен быть применён после сравнения.
\begin{lstlisting}[style=repl]
3> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
[{steak,5.99},
    {beer,3.99},
    {poutine,3.5},
    {kitten,20.99},
{water,0.0}]
4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
[{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]
\end{lstlisting}

Конечно, неплохо было бы округлить числа, для улучшения читаемости, но вы поняли в чём смысл.
Таким образом, списочные выражения в Erlang готовят по следующему рецепту: \ops{NewList = [Expression || Pattern}\\ 
\ops{ $<-$ List, Condition1, Condition2, ... ConditionN]}.
Элемент \ops{Pattern $<-$ List} называется Генератором.
И их может быть несколько!\\ 
\begin{lstlisting}[style=repl]
5> [X+Y || X <- [1,2], Y <- [2,3]].
[3,4,4,5]
\end{lstlisting}

Это выражение выполняет следующие операции: \ops{1 + 2},\ops{1 + 3},\ops{2 + 2},\ops{2 + 3}.
Так что в обобщённом виде вы получите: \ops{NewList = }\\ 
\ops{[Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN,}\\ 
\ops{Condition1, Condition2, ... ConditionM]}.
Обратите внимание, что выражения\--генераторы можно комбинировать с методом сопоставления с образцом и использовать в качестве фильтра:
\begin{lstlisting}[style=repl]
6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
    {montreal,storms},
    {london,fog},
    {paris,sun},
    {boston,fog},
{vancouver,snow}]
7> FoggyPlaces = [X || {X, fog} <- Weather].
[london,boston]
\end{lstlisting}

Если элемент списка <<Weather>> не совпадает с образцом \{X, fog\}, то в списочном выражении он просто игнорируется, тогда как при использовании с оператором \ops{=} было бы выброшено исключение.

Остался ещё один базовый тип данных, который мы должны рассмотреть.
В Erlang встроена функциональность, которая легко и просто позволяет преобразовывать двоичные данные.
\section{Битовый синтаксис!}
Во многих языках есть поддержка манипуляций с числами, атомами, кортежами, списками, записями и/или структурами и т.д.
Большинство этих языков содержат очень грубые методы манипулирования двоичными данными.
Erlang старается предоставить полезные абстракции для работы с двоичными данными при помощи усовершенствованного сопоставления с образцом.
Это превращает работу с сырыми двоичными данными в приятное и простое (я не вру) занятие.
Метод был создан для решения телекоммуникационных задач.
Битовые манипуляции предоставляют уникальный синтаксис и идиомы, которые на первый взгляд могут показаться странными, но обретают смысл, если вы имеете представление о том, как устроены биты и байты.
\textbf{В противном случае вам лучше пропустить остаток этой главы.}

Согласно битовому синтаксису, двоичные данные обрамляются символами $<<$ и $>>$, и их разделяют на читаемые сегменты при помощи запятых.
Сегмент \--- это последовательность бит в двоичном виде (не обязательно с выравниванием по границе байта, но такое выравнивание происходит по умолчанию).
Представим, что мы хотим хранить пиксель оранжевого цвета в 24\--битном представлении.
Если вам приходилось когда\--либо сталкиваться с цветовым представлением в Photoshop или в CSS, вам должна быть знакома запись в формате \#RRGGBB.
Оранжевый оттенок можно записать как \emph{\#F09A29}.
Erlang преобразует эту запись в следующий вид:
\begin{lstlisting}[style=repl]
1> Color = 16#F09A29.
15768105
2> Pixel = <<Color:24>>.
<<240,154,41>>
\end{lstlisting}

Это означает что\--то вроде: <<Расположи двоичное представление числа \emph{\#F09A29} в 24\--х битах (Красный в 8 битах, Зелёный в 8 и Синий тоже в 8 битах) переменной Pixel>>.
Значение можно будет позже взять и в неизменном виде записать в файл.
На первый взгляд ничего особенного в этом нет, но если вы откроете записанный файл в текстовом редакторе, то увидите лишь несколько нечитаемых символов.
Если этот файл считать при помощи Erlang, то его содержимое в двоичном представлении будет снова преобразовано в удобный формат \emph{$<<$240,151,41$>>$}!

Но ещё интереснее то, что для распаковки двоичных данных можно использовать сопоставление с образцом:
\begin{lstlisting}[style=repl]
3> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
4> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,64,76,32,76,
0,0,234,32,15>>
5> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
\end{lstlisting}

В 3\--й команде мы определили значение, которое соответствует двоичному представлению 4\--х пикселов в RGB пространстве.
В 4\--м выражении мы попытались распаковать 4 значения из двоичной величины.
В результате было выброшено исключение, так как в исходной величине не 4 сегмента, а 12!
Поэтому мы говорим Erlang, что каждая переменная слева будет содержать 24 бита.
Именно это и означает запись \ops{Var:24}.
Далее мы можем взять первый пиксел и распаковать его в отдельные цветовые компоненты:
\begin{lstlisting}[style=repl]
6> <<R:8, G:8, B:8>> = <<Pix1:24>>.
<<213,45,132>>
7> R.
213
\end{lstlisting}

<<Да, вышло неплохо.
А что если мне нужен лишь первый компонент?
Мне всё равно придётся постоянно распаковывать все значения?>>
Ха!
Прочь сомнения!
Erlang приходит на помощь, комбинируя синтаксический сахар и сопоставления с образцом:
\begin{lstlisting}[style=repl]
8> <<R:8, Rest/binary>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
9> R.
213
\end{lstlisting}

Неплохо, да?
А всё потому что Erlang воспринимает несколько способов описания двоичного сегмента.
Можно использовать все перечисленные ниже:

Value

Value:Size

Value/TypeSpecifierList

Value:Size/TypeSpecifierList

где Size указывает количество бит, а TypeSpecifierList обозначает одно или несколько понятий из следующего списка:

\begin{minipage}{\textwidth}
\textbf{Тип}\\ 
Возможные значения: \ops{integer | float | binary | bytes | bitstring | bits | utf8}\\ 
\ops{| utf16 | utf32}\\  
Так определяется вид используемых двоичных данных.
Заметьте, что 'bytes' это сокращение для 'binary', а 'bits'\--- сокращение для 'bitstring'.
Если тип не задан, Erlang использует тип 'integer'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Знак}\\ 
    Возможные значения: \ops{signed | unsigned}\\ 
    Имеет значение только при сопоставлении, когда тип \--- integer.
    По умолчанию используется 'unsigned'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Порядок байтов}\\ 
    Возможные значения: \ops{big | little | native}\\ 
    Порядок байтов имеет значение, когда задан тип integer, utf16, utf32 или float.
    От порядка зависит то, как система считывает двоичные данные.
    Например, заголовок изображения в формате BMP содержит размер файла в виде 4\--байтного целого числа.
    Пусть размер файла равен 72 байта, тогда little\--endian система представит его в виде \ops{$$<<$$72,0,0,0$$>>$$}, а big\--endian система в виде \ops{$$<<$$0,0,0,72$$>>$$}.
    Первое будет прочитано как '72', а второе как '1207959552', поэтому старайтесь чтобы порядок байтов был верным.
    Также существует опция 'native', которая устанавливает порядок байт, используемый процессором.
    По умолчанию используется порядок байт 'big'.\\ 
\end{minipage}

\begin{minipage}{\textwidth}
    \textbf{Единичный элемент}\\ 
    Записывается как \ops{unit:Integer}\\ 
    Это размер каждого сегмента в битах.
    Допустимый диапазон 1..256. По умолчанию равен 1 для integer, float, битовых строк и 8 для двоичных данных.
    Для типов utf8, utf16 и utf32 единицы определять не нужно.
    Произведение Размера на Единичный элемент равно количеству бит, которые занимает сегмент и должно быть кратным 8.
    Задание размера элемента часто используется для выравнивания по границе байта.\\  
\end{minipage}

Список TypeSpecifierList строится из атрибутов, разделённых символом '\--'.\\ 

Несколько примеров помогут разобраться в определениях:
\begin{lstlisting}[style=repl]
10> <<X1/unsigned>> =  <<-44>>.
<<"Ô">>
11> X1.
212
12> <<X2/signed>> =  <<-44>>. 
<<"Ô">>
13> X2.
-44
14> <<X2/integer-signed-little>> =  <<-44>>.
<<"Ô">>
15> X2.
-44
16> <<N:8/unit:1>> = <<72>>.
<<"H">>
17> N.
72
18> <<N/integer>> = <<72>>.
<<"H">>
19> <<Y:4/little-unit:8>> = <<72,0,0,0>>.     
<<72,0,0,0>>
20> Y.
72
\end{lstlisting}

Очевидно, что существует несколько способов читать, хранить и интерпретировать двоичные данные.
Немного сбивает с толку, но всё же это намного проще, чем обычные инструменты, которые предоставляет большинство языков.

В Erlang также существуют стандартные битовые операции (побитовый сдвиг влево и вправо, битовое 'и', 'или', 'исключающее или' и 'не').
Они реализованы функциями \ops{bsl} (Bit Shift Left (битовое смещение влево)), \ops{bsr} (Bit Shift Right (битовое смещение вправо)), \ops{band}, \ops{bor},\ops{bxor}, и \ops{bnot}.
\begin{lstlisting}[style=repl]
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
\end{lstlisting}

С такой записью и с таким битовым синтаксисом задача разбора и сопоставления с образцом двоичных данных сильно облегчается.
К примеру, таким кодом можно разобрать сегменты TCP пакета:
\begin{lstlisting}[style=repl]
<<SourcePort:16, DestinationPort:16,
AckNumber:32,
DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
CheckSum: 16, UrgentPointer:16,
Payload/binary>> = SomeBinary.
\end{lstlisting}

Ту же самую логику можно применять к любым двоичным данным: кодированное видео, изображения, реализация стороннего протокола и т.д.\\ 
\colorbox{lorange}
{
    \begin{minipage}{\linewidth}
        \textbf{Не забывайтесь:}\\ 
        Erlang, по сравнению с С и С++, язык медленный.
        Чтобы заниматься чем\--нибудь вроде конвертации видео или изображений на Erlang, нужно быть терпеливым человеком, хоть применение битового синтаксиса и делает эти задачи чрезвычайно интересными, о чём я намекнул чуть выше.
        Erlang просто не очень хорош для тяжёлых вычислительных задач.\\ 
        Но имейте в виду, что Erlang весьма быстр там, где не нужно постоянно молотить числа: реагирование на события, передача сообщений (здесь весьма кстати приходятся чрезвычайно лёгкие атомы) и т.д.
        Erlang может реагировать на события в сроки измеряемые миллисекундами, и поэтому прекрасно годится для применения в задачах мягкого реального времени (soft real time).\\ 
    \end{minipage}
}

\begin{wrapfigure}{r}{0.05\textwidth}
    \includegraphics[width=1\linewidth]{string.png}
\end{wrapfigure}

Для битовой записи также существует совершенно другое приложение: битовые строки.
Они не были задуманы как часть языка при проектированиию.
Их <<навесили>> позже, как и строки реализованные в виде списков.
Но они намного эффективнее строковых списков в отношении занимаемого пространства.
Происходит это потому, что обычные списки реализованы как связные списки (1 <<узел>> на каждую букву), а битовые строки больше похожи на массивы в языке C.
Для битовых строк используется синтаксис \ops{$<<$``this is a bit string!''$>>$}.
Недостатком битовых строк в сравнении со списками является потеря простоты в операциях сопоставления с образцом и в строковых манипуляциях.
По этой причине люди используют битовые строки для хранения текста, который не будет интенсивно меняться, либо в случаях, когда необходимо эффективно использовать память.\\ 
\colorbox{lgray}{
    \begin{minipage}{\linewidth}
        \textbf{Замечание:} хотя битовые строки довольно легковесны, их лучше не применять для пометки кортежей.
        Весьма соблазнительно было бы использовать строковый литерал, чтобы написать \ops{\{$<<$``temperature''$>>$,50\}}, но в таких случаях всегда используйте атомы.
        Ранее в этой главе было сказано, что атомы занимают всего 4 или 8 байт, независимо от их длины.
        Когда вы их используете, нет практически никаких издержек при копировании данных из функции в функцию или при их пересылке другому Erlang узлу на удалённом сервере.
        
        Верно и обратное: не используйте для замены строк атомы из\--за их лёгкости.
        Строками можно манипулировать (разбивка, регулярные выражения и т.д.) в то время как атомы можно только сравнивать, и больше с ними ничего не сделаешь.
    \end{minipage}
}
\section{Битовые выражения}
Битовые выражения являются для битового синтаксиса тем же, чем списочные выражения для списков: способом сделать код коротким и ясным.
В мире Erlang они появились относительно недавно.
В предыдущих версиях Erlang они присутствовали, но модуль, который их реализовывал, требовал для работы специальный флаг компиляции.
Начиная с ревизии R13B (о которой здесь идёт речь), они стали стандартом и могут быть использованы где угодно, включая оболочку:
\begin{lstlisting}[style=repl]
1> [ X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].    
[2,4]
\end{lstlisting}

Единственное отличие в синтаксисе от обычных списочных выражений это замена символа \ops{$<-$} на \ops{$<=$}, и использование двоичных данных ($<< >>$) вместо списков ([]).
Ранее в этой главе мы видели пример, в котором нам было дано двоичное значение, представляющее собой множество пикселов, к которому мы применили сопоставление с образцом, чтобы вычленить RGB значения для каждого пиксела.
В принципе, неплохой метод, но с большими структурами станет сложно читать и поддерживать такой код.
То же самое можно проделать при помощи однострочного битового выражения, которое выглядит значительно чище:
\begin{lstlisting}[style=repl]
2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
\end{lstlisting}

Замена \ops{$<-$} на \ops{$<=$} позволяет использовать двоичный поток как генератор.
Битовое выражение, по сути, преобразовывает двоичные данные в кортежи целых значений.
Существует также другой синтаксис битовых выражения, который позволяет совершить обратное преобразование:
\begin{lstlisting}[style=repl]
4> << <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
\end{lstlisting}

Будьте осторожны.
Для элементов результирующей двоичной величины необходимо чётко определить размер, в случае если генератор возвратил двоичные данные:
\begin{lstlisting}[style=repl]
5> << <<Bin>> || Bin <- [<<3,7,5,4,7>>] >>.
** exception error: bad argument
6> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>] >>. 
<<3,7,5,4,7>>
\end{lstlisting}

Также существует возможность использовать битовые выражения с двоичным генератором, если соблюдается вышеуказанное правило о предопределённом размере:
\begin{lstlisting}[style=repl]
7> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
<<4,8,6,5,8>>
\end{lstlisting}
\colorbox{lgray}
{
    \begin{minipage}{\linewidth}
        \textbf{Замечание:} на момент написания этого текста, битовые выражения использовались достаточно редко и были плохо документированы.
        Поэтому было принято решение не углубляться дальше основ.
        Чтобы получить более полное представление о битовом синтаксисе в целом, читайте \href{http://user.it.uu.se/~pergu/papers/erlang05.pdf}{документ, описывающий его спецификацию}.
    \end{minipage}
}
