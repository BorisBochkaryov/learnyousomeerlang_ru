\chapter{Решаем задачи в функциональном стиле}
\label{functionally-solving-problems}
\colorbox{lgray}
{
\begin{minipage}{1.0\linewidth}
    Похоже, что мы уже выпили достаточно эрлангового сока, чтобы сделать что\--нибудь полезное.
    В этой главе не будет ничего нового, а просто будет показано как применять элементы увиденного ранее.
    Задачи были взяты из книги Miran\--а \href{http://learnyouahaskell.com/functionally-solving-problems}{Learn You a Haskell}.
    Я использовал те же самые пути решения для того, чтобы любопытный читатель смог сравнивать решения на Erlang и Haskell как ему заблагорассудится.
    Если вы сделаете такое сравнение, то наверняка найдёте, что для двух языков с такими разными синтаксисами, конечные результаты очень похожи.
    Так происходит потому, что изученные концепции функционального программирования относительно легко переносить на другие функциональные языки.
\end{minipage}
}
\section{Калькулятор в обратной польской записи}
\label{reverse-polish-notation-calculator}
Большинство людей научились записывать арифметические выражения, помещая оператор между числами (\ops{(2 + 2) / 5}).
Так вводятся математические выражения в большинстве калькуляторов, и такую запись вас обучили использовать при счёте на школьных уроках. 
У этой записи есть недостаток: вам необходимо знать о порядке вычисления операторов.
Умножение и деление считается более важным (имеет более высокий приоритет), чем сложение и вычитание.

Существует ещё один способ записи, который называется \emph{префиксной записью} или \emph{польской записью}, в которой оператор записывается перед операндами.
В этой записи выражение \ops{(2 + 2) / 5} примет вид \ops{(/ (+ 2 2) 5)}.
Если мы решим, что \ops{+\strut}  и \ops{/\strut} должны всегда принимать два аргумента, то \ops{(/ (+ 2 2) 5)} можно просто записать как \ops{/ + 2 2 5}.

Однако, мы сосредоточимся на \emph{обратной польской записи} (или просто ОПЗ), которая противоположна префиксной записи: в ней оператор следует за операндами.
Тот же самый пример, приведённый выше, в ОПЗ будет записан как \ops{2 2 + 5 /}.
Можно привести и другие примеры: \ops{9 * 5 + 7} и \ops{10 * 2 * (3 + 5) / 2} транслируются соответственно в \ops{9 5 * 7} и \ops{10 2 * 3 4 + * 2 /}.
Эта запись очень широко использовалась в ранних моделях калькуляторов, так как требовала малого количества памяти.
А некоторые люди до сих пор носят с собой калькуляторы с ОПЗ.
Именно такой калькулятор мы и напишем.

Для начала неплохо было бы понять как читаются выражения ОПЗ.
Можно искать операторы один за одним и, учитывая арность, перегруппировывать их с операндами.
\begin{align*}
    &10\;4\;3+2 * -\\
    &10\;(4\;3\; +)\;2 * -\\
    &10\; ((4\; 3\; +)\; 2\; *) -\\ 
    &(10\; ((4\; 3\; +)\; 2\; *) -)\\
    &(10\; (7\; 2\; *) -)\\
    &(10\; 14\; -)\\
    &-4\\
\end{align*}

Но в компьютере или калькуляторе намного проще было бы создать \emph{стек} всех операндов в порядке их расположения.
Возьмём математическое выражение \ops{10 4 3 + 2 * -}.
Первый операнд 10.
Мы добавляем его в стек.
Затем идёт 4.
Его мы тоже кладём на вершину стека.
Третьим идёт число 3.
Мы помещаем в стек и его.
Теперь стек принял следующий вид:
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.12\textwidth]{stack1.png}
\end{figure}

Следующий символ это \ops{+\strut}.
Он представляет собой функцию арности 2.
Чтобы ею воспользоваться, нам необходимо  передать ей два операнда, которые мы извлечём из стека:
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{stack2.png}
\end{figure}

Полученную цифру 7 мы загоняем в верхушку стека (фу, мы же не хотим, чтобы эти грязные числа летали повсюду!)
Теперь стек содержит [7, 10], и от первоначального выражения осталось лишь \ops{2 * -}.
Мы берём 2 и помещаем его в вершину стека.
Затем мы видим операцию \ops{*\strut}, которой для работы необходимо передать два операнда.
И снова мы извлекаем их из стека:
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{stack3.png}
\end{figure}

И помещаем 14 в вершину стека.
Остаётся лишь \ops{-\strut}, которому необходимо два операнда.
О, невиданная удача!
В нашем стеке как раз осталось два операнда.
Используем же их!
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{stack4.png}
\end{figure}

А теперь мы получили результат.
Этот стек\--ориентированный подход относительно дуракоустойчив.
А то, что для начала вычислений требуется парсить мало данных, объясняет почему этот способ годится для старых калькуляторов.
Есть и другие причины для использования ОПЗ, но в этом руководстве они не обсуждаются.
За этим лучше обратиться к \href{http://en.wikipedia.org/wiki/Reverse_Polish_notation}{Статье на Wikipedia}.

Как только мы справились со сложными моментами, записать решение на Erlang становится достаточно просто.
Оказывается, что самое сложное \--- определить шаги для получения конечного результата.
А это мы только что проделали.
Неплохо.
Откройте файл \emph{\href{http://learnyousomeerlang.com/static/erlang/calc.erl}{calc.erl}}.

Для начала озаботимся представлением математических выражений.
Чтобы упростить задачу мы, наверное, представим их в виде строки: \ops{''10 4 3 + 2 * -''}.
В этой строке между термами есть пробелы, которые не оговорены в нашем решении, но необходимы для работы простого лексического анализатора.
После обработки анализатором неплохо было бы получить список термов вида \ops{[''10'',''4'',''3'',''+'',''2'',''*'',''-'']}.
Оказывается, функция \ops{\href{http://erldocs.com/R15B/stdlib/string.html\#tokens/2}{string:tokens/2}} делает именно то, что нам нужно:
\begin{lstlisting}[style=erlang]
1> string:tokens("10 4 3 + 2 * -", " ").
["10","4","3","+","2","*","-"]
\end{lstlisting}

Такое представление выражения нам подходит.
Следующим шагом мы должны определить стек.
Как мы это сделаем?
Вы, возможно, заметили, что поведение списков в Erlang очень похоже на стек.
Оператор (\ops{|}) в шаблоне \ops{[Head|Tail]} ведёт себя так же как и операция добавления \emph{Head} в вершину стека (которой в данном случае является \emph{Tail}).
Для наших нужд список вполне подойдёт на роль стека.

Чтобы прочитать выражение нам просто необходимо повторить те же действия, которые мы выполняли при решении задачи вручную.
Последовательно считываем каждое значение в выражении.
Если мы прочитали число \--- кладём его на стек.
Если функцию \--- извлекаем все необходимые ей значения из стека, а результат вычисления возвращаем обратно в стек.
Если обобщить задачу, то нам нужно один раз пройти в цикле по всему выражению и по ходу движения накапливать результаты.
С этим прекрасно справится свёртка (fold)!

Теперь мы должны выяснить, как будет выглядеть функция, которую \ops{\href{http://erldocs.com/R15B/stdlib/lists.html\#foldl/3}{lists:foldl/3}} будет применять к каждому оператору и операнду в нашем выражении.
Функция будет запускаться в свёртке, следовательно она должна принимать два аргумента: первый будет содержать элемент выражения, который будет обрабатывать функция, а вторым будет передаваться стек.

Начнём редактировать наш код в файле \ops{\href{http://learnyousomeerlang.com/static/erlang/calc.erl}{calc.erl}}.
Напишем функцию, в которой будет происходить итерация, а также удаление пробелов из выражения:
\begin{lstlisting}[style=erlang]
-module(calc).
-export([rpn/1]).
 
rpn(L) when is_list(L) ->
    [Res] = lists:foldl(fun rpn/2, [], string:tokens(L, " ")),
    Res.
\end{lstlisting}

Следующим шагом реализуем функцию \ops{rpn/2}.
Обратите внимание: каждый оператор и операнд из выражения в конце концов попадает на вершину стека, а поэтому и конечный результат вычислений также окажется в стеке.
Мы просто извлекаем последнее значение из стека и отдаём его пользователю.
Именно поэтому в сопоставлении с образцом мы используем шаблон \ops{[Res]} и возвращаем в результате \emph{Res}.

Хорошо, а теперь более сложная часть.
Наша функция \ops{rpn/2} должна обрабатывать стек для всех переданных ей значений.
Заголовок функции, скорее всего, будет выглядеть как \ops{rpn(Op,Stack)}, а возвращаемое значение примет вид \ops{[NewVal|Stack]}.
Для обычных чисел будет выполняться операция:
\begin{lstlisting}[style=erlang]
rpn(X, Stack) -> [read(X)|Stack].
\end{lstlisting}

Функция \ops{read/1} конвертирует строку в целое число или число с плавающей точкой.
К сожалению, в Erlang нет встроенной функции, которая делает и то и другое, поэтому мы создадим такую функцию сами:
\begin{lstlisting}[style=erlang]
read(N) ->
    case string:to_float(N) of
        {error,no_float} -> list_to_integer(N);
        {F,_} -> F
    end.
\end{lstlisting}

Где \ops{\href{http://erldocs.com/R15B/stdlib/string.html\#to\_float/1}{string:to\_float/1}} производит конвертацию строк вида ''13.37'' в их числовой эквивалент.
Если значение числа с плавающей точкой определить не удаётся, функция возвращает \ops{\{error,no\_float\}}.
В такой ситуации мы должны вызвать функцию \ops{list\_to\_integer/1}.

А теперь снова вернёмся к \ops{rpn/2}.
Все числа, которые нам попадаются, мы помещаем в стек.
Но так как наше сопоставление с образцом захватывает любые значения (см. \ref{pattern-matching}), то операторы тоже будут попадать в стек.
Чтобы этого избежать, мы добавим для всех операторов конкретные шаблоны, которые будут предварять общий.
Начнём со сложения:
\begin{lstlisting}[style=erlang]
rpn("+", [N1,N2|S]) -> [N2+N1|S];
rpn(X, Stack) -> [read(X)|Stack].
\end{lstlisting}

Мы видим, что каждый раз когда нам попадается строка \ops{''+''}, мы извлекаем из стека два числа \emph{(N1,N2)}, складываем их и возвращаем результат в стек.
Именно такие действия мы выполняли, когда решали задачу вручную.
Запустив программу, мы можем убедиться в её работоспособности:
\begin{lstlisting}[style=erlang]
1> c(calc).
{ok,calc}
2> calc:rpn("3 5 +").
8
3> calc:rpn("7 3 + 5 +").
15
\end{lstlisting}

Остальное \--- тривиально.
Нужно  лишь добавить такие же строки для всех оставшихся  операторов:
\begin{lstlisting}[style=erlang]
rpn("+", [N1,N2|S]) -> [N2+N1|S];
rpn("-", [N1,N2|S]) -> [N2-N1|S];
rpn("*", [N1,N2|S]) -> [N2*N1|S];
rpn("/", [N1,N2|S]) -> [N2/N1|S];
rpn("^", [N1,N2|S]) -> [math:pow(N2,N1)|S];
rpn("ln", [N|S])    -> [math:log(N)|S];
rpn("log10", [N|S]) -> [math:log10(N)|S];
rpn(X, Stack) -> [read(X)|Stack].
\end{lstlisting}

Обратите внимание, что функции, которые принимают лишь один аргумент (например функция логарифмирования), должны извлекать из стека один элемент.
Пусть читатель в качестве упражнения добавит функции функции 'sum' или 'prod', которые возвращают сумму или произведение всех элементов, cчитанных до сих пор.
В случае затруднений, обратитесь к моей реализации этих функций в \ops{\href{http://learnyousomeerlang.com/static/erlang/calc.erl}{calc.erl}}.

Чтобы убедиться, что всё работает как положено, мы напишем несколько простых юнит\--тестов.
Оператор \ops{=\strut} в Erlang может работать как функция \emph{assert}.
Она должна заканчиваться неудачей, если наткнулась на неожиданное значение.
Это как раз то, что нам нужно.
Конечно, в Erlang есть и более совершенные тестовые фреймворки, например \href{http://erlang.org/doc/apps/common_test/write_test_chapter.html}{Common Test} и \href{http://erlang.org/doc/apps/eunit/chapter.html}{EUnit}.
Мы поговорим о них позже, а сейчас нам хватит и \ops{=\strut}.
\begin{lstlisting}[style=erlang]
rpn_test() ->
    5 = rpn("2 3 +"),
    87 = rpn("90 3 -"),
    -4 = rpn("10 4 3 + 2 * -"),
    -2.0 = rpn("10 4 3 + 2 * - 2 /"),
    ok = try
        rpn("90 34 12 33 55 66 + * - +")
    catch
        error:{badmatch,[_|_]} -> ok
    end,
    4037 = rpn("90 34 12 33 55 66 + * - + -"),
    8.0 = rpn("2 3 ^"),
    true = math:sqrt(2) == rpn("2 0.5 ^"),
    true = math:log(2.7) == rpn("2.7 ln"),
    true = math:log10(2.7) == rpn("2.7 log10"),
    50 = rpn("10 10 10 20 sum"),
    10.0 = rpn("10 10 10 20 sum 5 /"),
    1000.0 = rpn("10 10 20 0.5 prod"),
    ok.
\end{lstlisting}

Тестовая функция перебирает все операции.
Тест считается пройденным, если не было возбуждено исключение.
Четыре первых теста проверяют корректную работу арифметических функций.
Пятый тест задаёт поведение, которое я ещё не обсуждал.
Выражение \ops{try \ldots catch} ожидает, что будет брошена  ошибка badmatch, так как было получено нерабочее выражение:
\begin{lstlisting}[style=erlang]
90 34 12 33 55 66 + * - +
90 (34 (12 (33 (55 66 +) *) -) +)
\end{lstlisting}

В конце функции \ops{rpn/1} значения -3947 и 90 остаются в стеке, так как не хватает оператора, который бы произвёл действие над числом 90.
Эту проблему можно решить двумя способами: можно её проигнорировать и просто взять значение, которое находится на вершине стека (это будет последний вычисленный результат), или сгенерировать ошибку, которая сообщает о неверных арифметических действиях.
Так как политика Erlang для таких случаев требует, чтобы мы позволили процессу упасть, то мы в этой ситуации сделаем выбор в пользу именно этого требования.
Сбой происходит в шаблоне \ops{[Res]} функции \ops{rpn/1}.
Шаблон проверяет, что в стеке остался лишь один элемент, и этот элемент \--- конечный результат вычислений.

Несколько тестов вида \ops{true = FunctionCall1 == FunctionCall2} были добавлены, так как  нельзя использовать вызов функции по левую сторону от \ops{=\strut}.
Они ведут себя как assert, потому что мы сравниваем результат сравнения с \emph{true}.

Также я добавил тесты для операторов sum и prod, чтобы вы смогли поупражняться в их реализации.
Если все тесты прошли успешно, то вы должны увидеть следующее:
\begin{lstlisting}[style=erlang]
1> c(calc).
{ok,calc}
2> calc:rpn_test().
ok
3> calc:rpn("1 2 ^ 2 2 ^ 3 2 ^ 4 2 ^ sum 2 -").
28.0
\end{lstlisting}

Где 28 действительно равно результату вычисления \ops{$sum(1^2 + 2^2 + 3^2 + 4^2) - 2$}.

Наш калькулятор можно улучшить, добавив возбуждение исключений \ops{badarith} в случае аварийного завершения из\--за неизвестных операторов или из\--за оставленных на стеке необработанных значений.
Такое исключение яснее обозначает проблему, чем ошибка \ops{badmatch}, которую мы генерируем сейчас.
Этим мы значительно облегчим отладку для пользователя модуля calc.

\section{Из Хитроу в Лондон}
\label{heathrow-to-london}
Следующая задача также взята из \href{http://learnyouahaskell.com/functionally-solving-problems#heathrow-to-london}{Learn You a Haskell}.
Вы летите в самолёте, который через несколько часов должен приземлиться в аэропорте Хитроу.
После приземления необходимо как можно быстрее добраться до Лондона.
Ваш богатый дядя при смерти, и вы хотите первым предъявить права на его недвижимость.

Из Хитроу в Лондон проложены две дороги, которые сообщаются при помощи  нескольких переулков.
Некоторые части дорог и переулков, из\--за ограничений скорости и заторов, позволяют ехать медленнее, чем обычно.
Перед посадкой вы решаете найти оптимальный путь, ведущий к дому, и, тем самым, максимизировать свои шансы.
Вот карта, которую вы нашли при помощи своего лэптопа:
\begin{figure}[h!]
    \includegraphics[width=0.7\textwidth]{road1.png}
\end{figure}

Так как после прочтения нескольких онлайн\--книг вы стали ярым фанатом Erlang\--а, то вы, конечно же, хотите решить эту задачу на вашем любимом языке.
Чтобы облегчить работу с картой, вы сохраняете исходные данные в файле \href{http://learnyousomeerlang.com/static/erlang/road.txt}{road.txt} следующим образом:
\begin{lstlisting}[style=erlang]
50
10
30
5
90
20
40
2
25
10
8
0
\end{lstlisting}

Дорога проложена по следующей схеме: \ops{A1, B1, X1, A2, B2, X2, ..., An, Bn, Xn}, где \emph{x} \--- это одна из дорог, которая соединяет между собой части А и B.
В качестве последнего сегмента \emph{x} мы используем 0, так как в этот момент мы гарантированно будем находиться в пункте назначения.
Данные можно организовать в кортежи по 3 элемента (тройки) вида \ops{\{A,B,X\}}.

И вот вы осознаёте, что эту проблему нечего даже пытаться решать на Erlang, если вы не знаете как решить её вручную.
Для анализа проблемы будем использовать то, чему нас научила рекурсия.

При написании рекурсивной функции мы первым шагом пытаемся найти базовый случай.
Для нашей проблемы таким случаем является ситуация, когда нам нужно проанализировать лишь один кортеж.
А именно, нам нужно выбирать между \emph{A, B} (и пересечением \emph{x}, которое в данном случае бесполезно, так как мы находимся в пункте назначения):
\begin{figure}[h!]
    \includegraphics[width=0.5\textwidth]{road2.png}
\end{figure}

Выбираем кратчайший путь.
Если вы хорошо изучили рекурсию, то знаете, что нужно стремиться к базовому случаю.
То есть на каждом шаге мы будем пытаться свести задачу к выбору между A и B.

Расширим нашу карту и начнём заново:
\begin{figure}[h!]
    \includegraphics[width=0.5\textwidth]{road3.png}
\end{figure}

О, становится интересно!
Как мы можем перейти от тройки \ops{\{5,1,3\}} к чёткому выбору между A и B?
Посмотрим, сколько существует вариантов для A.
Чтобы добраться до пересечения \emph{A1} и \emph{A2} (я буду называть это место \emph{точкой A1}), я могу поехать напрямую по дороге \emph{A1} (5), либо проехать по \emph{B1} (1), а затем по переулку \emph{X1} (3).
В этом случае первый вариант (5) длиннее второго (4).
Кратчайший путь для варианта А это \ops{[B, X]}.
А какие есть варианты для B?
Можно проехать по \emph{A1} (5), затем по переулку \emph{X1} (3), или сразу же избрать путь \emph{B1} (1).

Хорошо!
У нас есть путь длины 4 \ops{[B, X]} до первого пересечения А, и путь длины 1 \ops{[B]} до пересечения \emph{B1} и \emph{B2}.
Теперь мы должны сделать выбор между переходом ко второй точке A (пересечение \emph{A2} и конечной точки, либо \emph{X2}) и второй точкой B (пересечение \emph{B2} и \emph{X2}).
Для принятия решения предлагаю сделать то же самое, что и раньше.
Так как тексты здесь пишу именно я, то моё решение вам оспорить не удастся.
Ну что ж, продолжим!

Все возможные пути для этого случая можно найти таким же способом, как и для предыдущей ситуации.
До точки A мы можем добраться либо по пути \emph{A2} из \ops{[B, X]}, который даёт нам длину 14 (\ops{14 = 4 + 10}, либо по \emph{B2}, а затем \emph{X2} из точки \ops{[B]}, что даёт нам длину 16 (\ops{16 = 1 + 15 + 0}).
Очевидно, что путь \ops{[B, X, A]} лучше пути \ops{[B, B, X]}.
\begin{figure}[h!]
    \includegraphics[width=0.7\textwidth]{road3_2.png}
\end{figure}

Также мы можем добраться до следующей точки B по пути \emph{A2} из \ops{[B, X]} и переулку \emph{X2}, что даст нам длину 14 (\ops{14 = 4 + 10 + 0}).
Либо по дороге \emph{B2} из \emph{[B]}, которая даст нам путь длины 16 (\ops{16 = 1 + 15}).
Мы выберем первый вариант: \ops{[B, X, A, X]}.

Когда процесс окончен, у нас остаются два пути A и B.
Длина обоих равна 14.
Любой из этих маршрутов можно считать верным.
Последний выбор всегда будет происходить между двумя путями равной длины, если последний сегмент X имеет длину 0.
Наше рекурсивное решения даёт уверенность, что на выходе мы всегда получаем кратчайший путь.
Совсем неплохо, согласитесь.

Мы незаметно снабдили себя основными частями, которые необходимы для постройки рекурсивной функции.
Можете, конечно, её реализовать, если хотите, но я пообещал, что рекурсивные функции мы будем писать самостоятельно очень редко.
Здесь мы задействуем свёртку (fold).\\
\colorbox{lgray}
{
\begin{minipage}{1.0\linewidth}
    \textbf{Замечание:} хоть я и показывал, что свёртки используются для списков и создаются с их помощью, но свёртки представляют собой более широкую концепцию перебора элементов структуры данных при помощи аккумулятора.
Поэтому свёртки можно реализовывать над деревьями, отображениями (dictionaries), массивами, таблицами баз данных и т.д.

Во время экспериментов зачастую полезно использовать отображения (maps) и свёртки (folds).
С их помощью можно впоследствии легко изменить структуру данных, с которой работает логика вашей программы.
\end{minipage}
}

Итак, где мы остановились?
Ах, да!
Мы подготовили файл, который будем использовать как вход для нашей программы.
Для файловых манипуляций лучшим инструментом является \href{http://erldocs.com/R15B/kernel/file.html}{файловый модуль}.
Он содержит множество функций, которые встречаются в большинстве языков программирования и используются для работы с файлами (установка прав доступа, перемещение файлов, переименование и удаление и т.д.)

Модуль также содержит стандартные функции для чтения и/или записи из/в файлы, такие как \ops{\href{http://erldocs.com/R15B/kernel/file.html\#open/2}{file:open/2}} и \ops{\href{http://erldocs.com/R15B/kernel/file.html\#close/1}{file:close/1}}, которые делают именно то, о чём сообщают их имена (открывают и закрывают файлы!)
\ops{\href{http://erldocs.com/R15B/kernel/file.html\#read/2}{file:read/2}} извлекает из файла содержимое (в двоичном виде или в виде строки), \ops{\href{http://erldocs.com/R15B/kernel/file.html\#read\_line/1}{file:read\_line/1}} считывает единичную строку, \ops{\href{http://erldocs.com/R15B/kernel/file.html\#position/3}{file:position/3}} перемещает указатель в открытом файле в указанную позицию и т.д.
