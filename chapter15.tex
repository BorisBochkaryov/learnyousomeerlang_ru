\chapter{Проектируем конкурентное приложение}
\begin{wrapfigure}{r}{0.35\linewidth}
    \includegraphics[width=1\linewidth]{clock.png}
\end{wrapfigure}
Это всё прекрасно и хорошо.
Вы усвоили концепции, но, опять же, мы с самого начала книги занимались лишь игрушечными примерами: калькуляторами, деревьями, ездили из Хитроу в Лондон и т.д.
Пора сделать что\--нибудь более интересное с точки зрения обучения.
Мы напишем небольшое приложение на конкурентном Erlang.
Приложение будет линейным и простым, но в то же время полезным и в меру расширяемым.

Я немного неорганизованный человек.
Я запутался в домашних заданиях, благоустройстве квартиры, этой книге, работе, совещаниях, встречах и прочем.
У меня есть дюжина списков с задачами, которые я забываю сделать, или просто не нахожу для них времени.
Надеюсь, вам тоже иногда нужно напоминать о делах (хоть ваш разум  и не блуждает так же часто как мой), потому что мы напишем что\--то вроде приложения для напоминания о событиях, которое уведомляет о необходимости что\--либо сделать и напоминает о встречах.
\section{Разбираем задачу}
Перво\--наперво нужно понять, что мы вообще собираемся сделать.
Вы скажете: <<Напоминалку>>.
<<Ну, конечно>>, \--- скажу я.
Но это ещё не всё.
Как мы собираемся взаимодействовать с программой?
Что она должна для нас делать?
Как представить программу при помощи процессов?
Как узнать, какие нужно отсылать сообщения?

Как говорится: "Ходить по воде и разрабатывать программное обеспечение по техническому заданию одинаково просто, если и то и другое заморожено."
Так что давайте разработаем технические условия и будем их придерживаться.
Наша программа позволит совершать следующие действия:
\begin{itemize}
\item Добавлять событие.
У событий может быть крайний срок исполнения (момент времени, о котором необходимо предупредить), наименование события и его описание.
\item Показывать предупреждение, когда подошло время.
\item Отменять событие по его имени.
\item Не хранить данные на диске.
Для демонстрации архитектурных концепций, которые мы рассмотрим, это совершенно излишне.
Для настоящего приложения это, конечно никуда не годится, но вместо создания этой функциональности, я покажу, куда можно вставить код, если бы вам захотелось её реализовать, и укажу на несколько полезных функций, которые могли бы вам в этом помочь.
\item Так как постоянного хранилища у нас нет, мы должны иметь возможность изменять код во время исполнения.
\item Общение с программой будет осуществляться через командную строку, но мы должны предусмотреть возможность последующего расширения  средств взаимодействия (добавить, скажем, графический интерфейс, доступ через веб\--страницу, через систему обмена мгновенными сообщениями (instant messaging), е\--мейл и прочее).
\end{itemize}

Для нашей программы я избрал такой способ организации:
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{reminder-structure.png}
\end{figure}

Где клиент, сервер событий и x, y, z представлены в виде процессов.
Вот что каждый из них может делать:
\subsection{Сервер событий}
\begin{itemize}
\item Принимает подписки от клиентов
\item Передаёт уведомления от процессов, генерирующих события, каждому подписчику
\item Принимает сообщения о добавлении событий (и необходимости запуска процессов x, y, z)
\item Может принимать сообщения об отмене события, и последующем убийстве процессов\--генераторов событий
\item Может быть остановлен клиентом
\item Его код может быть перегружен из оболочки.
\end{itemize}
\subsection{Клиент}
\begin{itemize}
\item Подписывается на события у сервера событий и получает уведомления посредством сообщений.
Таким образом, можно легко создать группу клиентов, которые создают подписку на сервере событий.
Каждый клиент потенциально может служить шлюзом к различным точкам взаимодействия, упомянутым выше (графический интерфейс, веб\--страница, программа обмена мгновенными сообщениями, е\--мейл и т.д.)
\item Запрашивает у сервера создание события с необходимыми параметрами
\item Делает запрос к серверу на отмену события
\item Отслеживает сервер (на случай если тот прекратит работу)
\item При необходимости останавливает сервер событий
\end{itemize}
\subsection{x, y и z}
\begin{itemize}
\item С их помощью обозначаются уведомления, готовые к запуску (они реализованы в виде таймеров, связанных с сервером событий)
\item Отсылают сообщение серверу событий по истечении заданного периода
\item Получают сообщение об отмене и умирают
\end{itemize}

Обратите внимание, что все клиенты (IM, почта и т.д., которые в этой книге не реализованы) получают уведомления обо всех событиях, а отмена обычно не входит в список вещей, о которых следует предупреждать клиентов.
Эта программа предназначена для нас с вами, поэтому считается, что её будет запускать только один пользователь.

Вот более сложная схема, с указанием всех возможных сообщений:
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{reminder-bubbles-and-arrows.png}
\end{figure}

Здесь указан каждый процесс, который мы будем использовать.
Стрелки обозначают передаваемые сообщения.
С их помощью мы записали высокоуровневый протокол взаимодействия, ну или хотя бы его основу.

Нужно заметить, что для уведомлений мы используем по процессу на каждое событие.
Это слишком расточительно, и такое решение будет плохо масштабироваться в реальной задаче.
Но для приложения, единственным пользователем которого будете только вы, это вполне уместно.
Можно было бы решить эту проблему иначе, и использовать, к примеру, функцию \href{http://erldocs.com/R15B/stdlib/timer.html\#send_after/2}{timer:send\_after/2-3}, и тем самым избежать порождения большого количества процессов.
